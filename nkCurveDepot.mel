/*! © 2023 imaoki | MIT License | https://github.com/imaoki */

// /////////////////////////////////////////////////////////////////////////////
// ボイラープレート
// /////////////////////////////////////////////////////////////////////////////
/*1.0.0:Python*/proc string escapeStringForPython(string $input) {string $escapedText;int $size = `size $input`;for ($i = 1; $i <= $size; $i++) {string $c = `substring $input $i $i`;switch ($c) {case "\\": $escapedText += "\\\\"; break;case "'": $escapedText += "\\'"; break;case "\n": $escapedText += "\\n"; break;case "\r": $escapedText += "\\r"; break;default: $escapedText += $c; break;}}return $escapedText;}proc string convertStringForPythonString(string $input) {return ("'" + escapeStringForPython($input) + "'");}proc string convertStringArrayForPythonList(string $input[]) {string $literal = "[";for ($i = 0; $i < `size $input`; $i++) {if ($i > 0) {$literal += ", ";}$literal += convertStringForPythonString($input[$i]);}$literal += "]";return $literal;}proc string convertStringArrayForPythonTuple(string $input[]) {string $literal = "(";for ($i = 0; $i < `size $input`; $i++) {if ($i > 0) {$literal += ", ";}$literal += convertStringForPythonString($input[$i]);}$literal += ")";return $literal;}
// -----------------------------------------------------------------------------
/*1.2.0:Assertion*/proc string assertTrue(int $a) {return ($a == true) ? "" : ("Assert: expected 1, got " + $a);}proc string assertFalse(int $a) {return ($a == false) ? "" : ("Assert: expected 0, got " + $a);}proc string assertFloatEqual(float $e, float $a, float $t) {return (`abs ($e - $a)` <= $t) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertFloatNotEqual(float $e, float $a, float $t) {return (`abs ($e - $a)` > $t) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertIntEqual(int $e, int $a) {return ($a == $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertIntNotEqual(int $e, int $a) {return ($a != $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringEqual(string $e, string $a) {return ($a == $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringNotEqual(string $e, string $a) {return ($a != $e) ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringMatch(string $e, string $a) {return (!`size $e` || `match $e $a` != "") ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertStringMismatch(string $e, string $a) {return (!`size $e` || `match $e $a` == "") ? "" : ("Assert: expected " + $e + ", got " + $a);}proc string assertFloatArrayEqual(float $es[], float $as[], float $t) {int $numAs = `size $as`;int $isEqual = $numAs == `size $es`;if ($isEqual) {for ($i = 0; $i < $numAs; $i++) {$isEqual = `abs ($es[$i] - $as[$i])` <= $t;if (!$isEqual) break;}}return ($isEqual) ? "" : ("Assert: expected {" + floatArrayToString($es, ", ") + "}, got {" + floatArrayToString($as, ", ") + "}");}proc string assertIntArrayEqual(int $es[], int $as[]) {int $numAs = `size $as`;int $isEqual = $numAs == `size $es`;if ($isEqual) {for ($i = 0; $i < $numAs; $i++) {$isEqual = $as[$i] == $es[$i];if (!$isEqual) break;}}return ($isEqual) ? "" : ("Assert: expected {" + intArrayToString($es, ", ") + "}, got {" + intArrayToString($as, ", ") + "}");}proc string assertStringArrayEqual(string $es[], string $as[]) {int $numAs = `size $as`;int $isEqual = $numAs == `size $es`;if ($isEqual) {for ($i = 0; $i < $numAs; $i++) {$isEqual = $as[$i] == $es[$i];if (!$isEqual) break;}}return ($isEqual) ? "" : ("Assert: expected {" + stringArrayToString($es, ", ") + "}, got {" + stringArrayToString($as, ", ") + "}");}proc testNewScene() {file -f -new;}proc testOpenScene(string $filename) {file -f -op "v=0;"  -iv  -typ "mayaAscii" -pmt false -o $filename;}
/*1.15.1:Attribute*/proc int existsAttribute(string $node, string $attribute) {if (!`objExists $node`) return false;if (`gmatch $attribute "*\\[*\\]"`) {string $buffer[];if (`tokenize $attribute "[]" $buffer` < 2) return false;return `attributeQuery -ex -n $node $buffer[0]`;}else if (`gmatch $attribute "*.*"`) {string $buffer[];int $numBuffer = `tokenize $attribute "." $buffer`;if ($numBuffer < 2) return false;string $parentAttribute = $node;for ($i = 0; $i < $numBuffer - 1; $i++) {$parentAttribute += "." + $buffer[$i];}string $targetAttribute = $buffer[$numBuffer - 1];return `attributeQuery -ex -n $parentAttribute $targetAttribute`;}else {return `attributeQuery -ex -n $node $attribute`;}}proc string getAttributeType(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return "";return `getAttr -typ ($node + "." + $attribute)`;}proc int isAttributeType(string $node, string $attribute, string $type) {return (getAttributeType($node, $attribute) == $type);}proc int isAttributeSettable(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return false;return `getAttr -se ($node + "." + $attribute)`;}proc int isAttributeKeyable(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return false;return `getAttr -k ($node + "." + $attribute)`;}proc setAttributeKeyable(string $node, string $attribute, int $state) {if (!existsAttribute($node, $attribute)) return;setAttr -k $state ($node + "." + $attribute);}proc batchSetAttributeKeyable(string $nodes[], string $attributes[], int $state) {for ($n in $nodes) {for ($attribute in $attributes) {setAttributeKeyable($n, $attribute, $state);}}}proc int isAttributeChannelBox(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return false;return `getAttr -cb ($node + "." + $attribute)`;}proc setAttributeChannelBox(string $node, string $attribute, int $state) {if (!existsAttribute($node, $attribute)) return;if (!$state) {setAttributeKeyable($node, $attribute, $state);}setAttr -cb $state ($node + "." + $attribute);}proc batchSetAttributeChannelBox(string $nodes[], string $attributes[], int $state) {for ($n in $nodes) {for ($attribute in $attributes) {setAttributeChannelBox($n, $attribute, $state);}}}proc int isAttributeLocked(string $node, string $attribute) {if (!existsAttribute($node, $attribute)) return true;return `getAttr -l ($node + "." + $attribute)`;}proc setAttributeLock(string $node, string $attribute, int $state) {if (!existsAttribute($node, $attribute)) return;setAttr -l $state ($node + "." + $attribute);}proc batchSetAttributeLock(string $nodes[], string $attributes[], int $state) {for ($n in $nodes) {for ($attribute in $attributes) {setAttributeLock($n, $attribute, $state);}}}proc string[] getEnumLabels(string $node, string $attribute) {string $labels[];if (!isAttributeType($node, $attribute, "enum")) return $labels;string $enumLabels[] = `attributeQuery -le -n $node $attribute`;if (!(`size $enumLabels` && `size $enumLabels[0]`)) return $labels;tokenize $enumLabels[0] ":" $labels;if (`size $labels` == 1 && !`size $labels[0]`) clear $labels;return $labels;}proc string attributeNameInPascalCase(string $node, string $attribute) {string $pascalName;if (!existsAttribute($node, $attribute)) return $pascalName;$pascalName = `attributeName -n ($node + "." + $attribute)`;$pascalName = substituteAllString($pascalName, " ", "");return $pascalName;}proc int addProxyAttributes(string $sourceNode,string $attributes[],string $proxyNode) {if ( !`objExists $sourceNode` || !`size $attributes` || !`objExists $proxyNode`) return false;for ($attribute in $attributes) {if ( !existsAttribute($sourceNode, $attribute) || existsAttribute($proxyNode, $attribute)) continue;addAttr -ln $attribute -pxy ($sourceNode + "." + $attribute) $proxyNode;}return true;}proc float getFloatAttribute(string $node, string $attribute, float $default) {if (!existsAttribute($node, $attribute)) return $default;return `getAttr ($node + "." + $attribute)`;}proc setFloatAttribute(string $node, string $attribute, float $value) {if (!isAttributeSettable($node, $attribute)) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($value > $max[0]) $value = $max[0];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($value < $min[0]) $value = $min[0];}setAttr ($node + "." + $attribute) $value;}proc batchSetFloatAttribute(string $nodes[], string $attribute, float $value) {for ($n in $nodes) {setFloatAttribute($n, $attribute, $value);}}proc float[] getFloat3Attribute(string $node, string $attribute, float $defaults[]) {if (!existsAttribute($node, $attribute)) return $defaults;return `getAttr ($node + "." + $attribute)`;}proc setFloat3Attribute(string $node, string $attribute, float $values[]) {if (!isAttributeSettable($node, $attribute) || `size $values` != 3) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($values[0] > $max[0]) $values[0] = $max[0];if ($values[1] > $max[1]) $values[1] = $max[1];if ($values[2] > $max[2]) $values[2] = $max[2];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($values[0] < $min[0]) $values[0] = $min[0];if ($values[1] < $min[1]) $values[1] = $min[1];if ($values[2] < $min[2]) $values[2] = $min[2];}setAttr ($node + "." + $attribute) $values[0] $values[1] $values[2];}proc batchSetFloat3Attribute(string $nodes[], string $attribute, float $values[]) {for ($n in $nodes) {setFloat3Attribute($n, $attribute, $values);}}proc int getIntAttribute(string $node, string $attribute, int $default) {if (!existsAttribute($node, $attribute)) return $default;return `getAttr ($node + "." + $attribute)`;}proc setIntAttribute(string $node, string $attribute, int $value) {if (!isAttributeSettable($node, $attribute)) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($value > $max[0]) $value = (int) $max[0];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($value < $min[0]) $value = (int) $min[0];}setAttr ($node + "." + $attribute) $value;}proc batchSetIntAttribute(string $nodes[], string $attribute, int $value) {for ($n in $nodes) {setIntAttribute($n, $attribute, $value);}}proc int[] getInt3Attribute(string $node, string $attribute, int $defaults[]) {if (!existsAttribute($node, $attribute)) return $defaults;return `getAttr ($node + "." + $attribute)`;}proc setInt3Attribute(string $node, string $attribute, int $values[]) {if (!isAttributeSettable($node, $attribute) || `size $values` != 3) return;if (`attributeQuery -mxe -n $node $attribute`) {float $max[] = `attributeQuery -max -n $node $attribute`;if ($values[0] > $max[0]) $values[0] = (int) $max[0];if ($values[1] > $max[1]) $values[1] = (int) $max[1];if ($values[2] > $max[2]) $values[2] = (int) $max[2];}if (`attributeQuery -mne -n $node $attribute`) {float $min[] = `attributeQuery -min -n $node $attribute`;if ($values[0] < $min[0]) $values[0] = (int) $min[0];if ($values[1] < $min[1]) $values[1] = (int) $min[1];if ($values[2] < $min[2]) $values[2] = (int) $min[2];}setAttr ($node + "." + $attribute) $values[0] $values[1] $values[2];}proc batchSetInt3Attribute(string $nodes[], string $attribute, int $values[]) {for ($n in $nodes) {setInt3Attribute($n, $attribute, $values);}}proc string getStringAttribute(string $node, string $attribute, string $default) {string $value = $default;if (!existsAttribute($node, $attribute)) return $value;$value = `getAttr ($node + "." + $attribute)`;if (!`size $value`) $value = "";return $value;}proc setStringAttribute(string $node, string $attribute, string $value) {if (!isAttributeSettable($node, $attribute)) return;setAttr ($node + "." + $attribute) -typ "string" $value;}proc batchSetStringAttribute(string $nodes[], string $attribute, string $value) {for ($n in $nodes) {setStringAttribute($n, $attribute, $value);}}proc string[] getSourceConnections(string $n,string $attributes[],string $type,string $sourceAttributes[],string $targetAttributes[]) {string $sourceNodes[];clear $sourceAttributes;clear $targetAttributes;if (!`objExists $n`) return $sourceNodes;$n = longNameOf($n);int $typeFlag = `size $type` > 0;if (`size $attributes`) {for ($attribute in $attributes) {if (!existsAttribute($n, $attribute)) continue;string $destPath = $n + "." + $attribute;string $nodes[];if ($typeFlag) {$nodes = `listConnections -d false -p false -s true -t $type $destPath`;}else {$nodes = `listConnections -d false -p false -s true $destPath`;}$sourceNodes = stringArrayCatenate($sourceNodes, $nodes);string $plugs[];if ($typeFlag) {$plugs = `listConnections -d false -p true -s true -t $type $destPath`;}else {$plugs = `listConnections -d false -p true -s true $destPath`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];if (`tokenize $plug "." $buffer` != 2) continue;string $sourcePath = longNameOf($buffer[0]) + "." + $buffer[1];$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}else {string $plugs[];if ($typeFlag) {$sourceNodes = `listConnections -d false -p false -s true -t $type $n`;$plugs = `listConnections -d false -p true -s true -t $type $n`;}else {$sourceNodes = `listConnections -d false -p false -s true $n`;$plugs = `listConnections -d false -p true -s true $n`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];if (`tokenize $plug "." $buffer` != 2) continue;string $sourcePath = longNameOf($buffer[0]) + "." + $buffer[1];string $targetPlugs[] = `listConnections -d true -p true -s false $sourcePath`;$targetPlugs = stringArrayRemoveDuplicates($targetPlugs);for ($targetPlug in $targetPlugs) {string $targetBuffer[];if (`tokenize $targetPlug "." $targetBuffer` != 2) continue;string $targetNode = longNameOf($targetBuffer[0]);if ($targetNode != $n) continue;string $destPath = $targetNode + "." + $targetBuffer[1];$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}$sourceNodes = stringArrayRemoveDuplicates($sourceNodes);for ($i = 0; $i < `size $sourceNodes`; $i++) {$sourceNodes[$i] = longNameOf($sourceNodes[$i]);}return $sourceNodes;}proc string[] getDestConnections(string $n,string $attributes[],string $type,string $sourceAttributes[],string $targetAttributes[]) {string $destNodes[];clear $sourceAttributes;clear $targetAttributes;if (!`objExists $n`) return $destNodes;$n = longNameOf($n);int $typeFlag = `size $type` > 0;if (`size $attributes`) {for ($attribute in $attributes) {if (!existsAttribute($n, $attribute)) continue;string $sourcePath = $n + "." + $attribute;string $nodes[];if ($typeFlag) {$nodes = `listConnections -d true -p false -s false -t $type $sourcePath`;}else {$nodes = `listConnections -d true -p false -s false $sourcePath`;}$destNodes = stringArrayCatenate($destNodes, $nodes);string $plugs[];if ($typeFlag) {$plugs = `listConnections -d true -p true -s false -t $type $sourcePath`;}else {$plugs = `listConnections -d true -p true -s false $sourcePath`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];if (`tokenize $plug "." $buffer` != 2) continue;string $destPath = longNameOf($buffer[0]) + "." + $buffer[1];$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}else {string $plugs[];if ($typeFlag) {$destNodes = `listConnections -d true -p false -s false -t $type $n`;$plugs = `listConnections -d true -p true -s false -t $type $n`;}else {$destNodes = `listConnections -d true -p false -s false $n`;$plugs = `listConnections -d true -p true -s false $n`;}$plugs = stringArrayRemoveDuplicates($plugs);for ($plug in $plugs) {string $buffer[];if (`tokenize $plug "." $buffer` != 2) continue;string $destPath = longNameOf($buffer[0]) + "." + $buffer[1];string $sourcePlugs[] = `listConnections -d false -p true -s true $destPath`;$sourcePlugs = stringArrayRemoveDuplicates($sourcePlugs);for ($sourcePlug in $sourcePlugs) {string $sourceBuffer[];if (`tokenize $sourcePlug "." $sourceBuffer` != 2) continue;string $sourceNode = longNameOf($sourceBuffer[0]);if ($sourceNode != $n) continue;string $sourcePath = $sourceNode + "." + $sourceBuffer[1];$sourceAttributes[`size $sourceAttributes`] = $sourcePath;$targetAttributes[`size $targetAttributes`] = $destPath;}}}$destNodes = stringArrayRemoveDuplicates($destNodes);for ($i = 0; $i < `size $destNodes`; $i++) {$destNodes[$i] = longNameOf($destNodes[$i]);}return $destNodes;}proc connectAttributes(string $sourceAttributes[],string $targetAttributes[],int $force) {int $numAttributes = `size $sourceAttributes`;if (`size $targetAttributes` != $numAttributes) return;for ($i = 0; $i < $numAttributes; $i++) {string $sourceAttribute = $sourceAttributes[$i];string $targetAttribute = $targetAttributes[$i];if (`isConnected -iuc $sourceAttribute $targetAttribute`) continue;if ($force) {connectAttr -f $sourceAttribute $targetAttribute;}else {connectAttr $sourceAttribute $targetAttribute;}}}proc disconnectAttributes(string $sourceAttributes[],string $targetAttributes[]) {int $numAttributes = `size $sourceAttributes`;if (`size $targetAttributes` != $numAttributes) return;for ($i = 0; $i < $numAttributes; $i++) {string $sourceAttribute = $sourceAttributes[$i];string $targetAttribute = $targetAttributes[$i];if (!`isConnected -iuc $sourceAttribute $targetAttribute`) continue;disconnectAttr $sourceAttribute $targetAttribute;}}proc initializeRenderStats(string $nodes[]) {if (!`size $nodes`) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "castsShadows", true);setIntAttribute($n, "receiveShadows", true);setIntAttribute($n, "holdOut", false);setIntAttribute($n, "motionBlur", true);setIntAttribute($n, "primaryVisibility", true);setIntAttribute($n, "smoothShading", true);setIntAttribute($n, "visibleInReflections", true);setIntAttribute($n, "visibleInRefractions", true);setIntAttribute($n, "doubleSided", true);setIntAttribute($n, "opposite", false);setIntAttribute($n, "geometryAntialiasingOverride", false);setIntAttribute($n, "antialiasingLevel", 1);setIntAttribute($n, "shadingSamplesOverride", false);setIntAttribute($n, "shadingSamples", 1);setIntAttribute($n, "maxShadingSamples", 1);}}proc disableRenderStats(string $nodes[]) {if (!`size $nodes`) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "castsShadows", false);setIntAttribute($n, "receiveShadows", false);setIntAttribute($n, "holdOut", false);setIntAttribute($n, "motionBlur", false);setIntAttribute($n, "primaryVisibility", false);setIntAttribute($n, "smoothShading", false);setIntAttribute($n, "visibleInReflections", false);setIntAttribute($n, "visibleInRefractions", false);setIntAttribute($n, "doubleSided", false);setIntAttribute($n, "opposite", false);setIntAttribute($n, "geometryAntialiasingOverride", false);setIntAttribute($n, "shadingSamplesOverride", false);}}proc setOutlinerColor(string $nodes[], float $color[]) {if (!`size $nodes` || `size $color` != 3) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "uocol", true);setFloat3Attribute($n, "oclr", $color);}}proc setOverrideColor(string $nodes[], int $index) {if (!(0 <= $index && $index <= 31)) return;for ($n in $nodes) {if (!`objExists $n`) continue;setIntAttribute($n, "ove", true);setIntAttribute($n, "ovrgbf", 0);setIntAttribute($n, "ovc", $index);}}proc int hasShapeTransformAttributes(string $n) {return (isAttributeType($n, "shapeTranslate", "double3") && isAttributeType($n, "shapeTranslateX", "doubleLinear") && isAttributeType($n, "shapeTranslateY", "doubleLinear") && isAttributeType($n, "shapeTranslateZ", "doubleLinear") && isAttributeType($n, "shapeRotate", "double3") && isAttributeType($n, "shapeRotateX", "doubleAngle") && isAttributeType($n, "shapeRotateY", "doubleAngle") && isAttributeType($n, "shapeRotateZ", "doubleAngle") && isAttributeType($n, "shapeScale", "double3") && isAttributeType($n, "shapeScaleX", "double") && isAttributeType($n, "shapeScaleY", "double") && isAttributeType($n, "shapeScaleZ", "double"));}proc addShapeTransformAttributes(string $n) {if (!`objExists $n` || hasShapeTransformAttributes($n)) return;addAttr -at "double3"      -k false -ln "shapeTranslate"  -sn "st" $n;addAttr -at "doubleLinear" -k false -ln "shapeTranslateX" -sn "stx" -p "shapeTranslate" $n;addAttr -at "doubleLinear" -k false -ln "shapeTranslateY" -sn "sty" -p "shapeTranslate" $n;addAttr -at "doubleLinear" -k false -ln "shapeTranslateZ" -sn "stz" -p "shapeTranslate" $n;addAttr -at "double3"      -k false -ln "shapeRotate"     -sn "sr" $n;addAttr -at "doubleAngle"  -k false -ln "shapeRotateX"    -sn "srx" -p "shapeRotate" $n;addAttr -at "doubleAngle"  -k false -ln "shapeRotateY"    -sn "sry" -p "shapeRotate" $n;addAttr -at "doubleAngle"  -k false -ln "shapeRotateZ"    -sn "srz" -p "shapeRotate" $n;addAttr -at "double3"      -k false -ln "shapeScale"      -sn "ss" $n;addAttr -at "double"       -k false -ln "shapeScaleX"     -sn "ssx" -p "shapeScale" $n;addAttr -at "double"       -k false -ln "shapeScaleY"     -sn "ssy" -p "shapeScale" $n;addAttr -at "double"       -k false -ln "shapeScaleZ"     -sn "ssz" -p "shapeScale" $n;setAttr ($n + ".ss") -typ "double3" 1.0 1.0 1.0;}proc int hasCurveNameAttribute(string $n) {return isAttributeType($n, "curveName", "string");}proc addCurveNameAttribute(string $n) {if (!`objExists $n` || hasCurveNameAttribute($n)) return;addAttr -dt "string" -ln "curveName" -sn "cn" $n;}
/*1.6.0:File*/proc int isValidFilename(string $input) {return (`match "[:\?\"\*/\\<>\|\n\r\t]" $input` == "");}proc string escapeInvalidFileNameChars(string $input, string $replacement) {python("import re");string $result = `python("re.sub(r" + convertStringForPythonString("[:\?\"\*/\\<>\|\n\r\t]") + ", " + convertStringForPythonString($replacement) + ", " + convertStringForPythonString($input) + ")")`;return $result;}proc string getSourceFilename(string $procName) {string $filename;string $thisIs = `whatIs $procName`;string $pattern1 = "^Mel procedure found in: *";string $pattern2 = "^Script found in: *";if (`match $pattern1 $thisIs` != "") {$filename = `substitute $pattern1 $thisIs ""`;}else if (`match $pattern2 $thisIs` != "") {$filename = `substitute $pattern2 $thisIs ""`;}return $filename;}proc string getSourceDirname(string $procName) {return dirname(getSourceFilename($procName));}proc int existsDirname(string $dirname) {return `filetest -d $dirname`;}proc int existsFilename(string $filename) {return `filetest -f $filename`;}proc string[] getDirnames(string $dirname) {string $subDirnames[];string $filenames[] = `getFileList -fld $dirname`;for ($i = 0; $i < `size $filenames`; $i++) {string $subDirname = $dirname + "/" + $filenames[$i];if (existsDirname($subDirname)) {$subDirnames[`size $subDirnames`] = $subDirname;}}$subDirnames = `sortCaseInsensitive $subDirnames`;return $subDirnames;}proc string[] getFilenames(string $dirname, string $filenamePattern) {string $filenames[] = `getFileList -fs $filenamePattern -fld $dirname`;for ($i = 0; $i < `size $filenames`; $i++) {$filenames[$i] = $dirname + "/" + $filenames[$i];}$filenames = `sortCaseInsensitive $filenames`;return $filenames;}proc string getOpenFilename(string $caption, string $fileFilter) {string $filename;string $filenames[] = `fileDialog2 -cap $caption -ds 2 -ff $fileFilter -fm 1`;if (`size $filenames`) $filename = $filenames[0];return $filename;}proc string getSaveFilename(string $caption, string $fileFilter) {string $filename;string $filenames[] = `fileDialog2 -cap $caption -ds 2 -ff $fileFilter -fm 0`;if (`size $filenames`) $filename = $filenames[0];return $filename;}proc string[] readAllLines(string $filename, string $encoding) {if (!`size $encoding`) $encoding = "utf-8";string $lines[];if (!existsFilename($filename)) return $lines;python("with open('" + $filename + "', 'r', encoding='" + $encoding + "') as f:" + " lines = tuple(s.rstrip('\\r\\n') for s in f.readlines())");$lines = `python("lines")`;return $lines;}proc string readAllText(string $filename, string $encoding) {if (!`size $encoding`) $encoding = "utf-8";string $text;if (!existsFilename($filename)) return $text;python("with open('" + $filename + "', 'r', encoding='" + $encoding + "') as f: text = f.read()");$text = `python("text")`;return $text;}proc int writeAllText(string $filename, string $encoding, string $input) {string $dirname = dirname($filename);if (!existsDirname($dirname)) return false;if (!`size $encoding`) $encoding = "utf-8";python("with open(" + convertStringForPythonString($filename) + ", 'w', encoding=" + convertStringForPythonString($encoding) + ") as f:" + " num = f.write(" + convertStringForPythonString($input) + ")");return (existsFilename($filename));}proc int writeAllLines(string $filename, string $encoding, string $lines[]) {string $text = stringArrayToString($lines, "\n");if (`size $lines`) $text += "\n";return (writeAllText($filename, $encoding, $text));}proc int makeDirs(string $dirname) {if (existsDirname($dirname)) return true;if (existsFilename($dirname)) return false;python("import os");python("os.makedirs('" + $dirname + "')");return (existsDirname($dirname));}proc int moveDir(string $sourceDirname, string $destDirname) {if (!existsDirname($sourceDirname)) return false;if (existsDirname($destDirname) || existsFilename($destDirname)) return false;python("import os");python("os.rename('" + $sourceDirname + "', '" + $destDirname +"')");return (!existsDirname($sourceDirname) && existsDirname($destDirname));}proc int moveFile(string $sourceFilename, string $destFilename) {if (!existsFilename($sourceFilename)) return false;if (existsDirname($destFilename) || existsFilename($destFilename)) return false;python("import os");python("os.rename('" + $sourceFilename + "', '" + $destFilename +"')");return (!existsFilename($sourceFilename) && existsFilename($destFilename));}proc int deleteDir(string $dirname) {if (!existsDirname($dirname)) return false;python("import os");python("if len(os.listdir('" + $dirname + "')) == 0:" + " os.rmdir('" + $dirname + "')");return (!existsDirname($dirname));}proc int deleteFile(string $filename) {if (!existsFilename($filename)) return false;python("import os");python("os.remove('" + $filename + "')");return (!existsFilename($filename));}
/*1.18.1:Node*/proc int nodesExists(string $nodes[]) {int $numNodes = `size $nodes`;if (!$numNodes) return false;int $count;for ($n in $nodes) {if (`objExists $n`) $count += 1;}return ($count == $numNodes);}proc int isSelected(string $n) {if (!`objExists $n`) return false;string $nodes[] = `ls -l -sl $n`;return (`size $nodes` > 0);}proc string[] getShapeNodes(string $n, string $type) {if (!`objExists $n`) return {};if (`size $type`) {return `listRelatives -f -s -typ $type $n`;}else {return `listRelatives -f -s $n`;}}proc int isType(string $n, string $types[], int $isExact) {if (!`objExists $n`) return false;if (!`size $types`) return true;if ($isExact) {if (stringArrayContains(`nodeType $n`, $types)) return true;}else {string $subtypes[] = `nodeType -i $n`;for ($subtype in $subtypes) {if (stringArrayContains($subtype, $types)) return true;}}return false;}proc int hasType(string $n, string $types[], int $isExact) {if (isType($n, $types, $isExact)) return true;string $shapeNodes[] = getShapeNodes($n, "");for ($shapeNode in $shapeNodes) {if (isType($shapeNode, $types, $isExact)) return true;}return false;}proc int isTypeContains(string $nodes[], string $types[], int $isExact) {if (!`size $nodes`) return false;if (!`size $types`) return true;for ($n in $nodes) {if (isType($n, $types, $isExact)) return true;}return false;}proc int isNodeReferenced(string $n) {return (`objExists $n` && `referenceQuery -inr $n`);}proc int isConstraintNode(string $n) {return isType($n, {"constraint"}, false);}proc int isDagNode(string $n) {return isType($n, {"dagNode"}, false);}proc int isTransformNode(string $n) {return isType($n, {"transform"}, true);}proc int isJointNode(string $n) {return isType($n, {"joint"}, true);}proc int isShapeNode(string $n) {return isType($n, {"shape"}, false);}proc int isLocatorNode(string $n) {return isType($n, {"locator"}, true);}proc int hasLocatorNode(string $n) {return hasType($n, {"locator"}, true);}proc int isNurbsSurfaceNode(string $n) {return isType($n, {"nurbsSurface"}, true);}proc int hasNurbsSurfaceNode(string $n) {return hasType($n, {"nurbsSurface"}, true);}proc int isNurbsCurveNode(string $n) {return isType($n, {"nurbsCurve"}, true);}proc int hasNurbsCurveNode(string $n) {return hasType($n, {"nurbsCurve"}, true);}proc int isBezierCurveNode(string $n) {return isType($n, {"bezierCurve"}, true);}proc int hasBezierCurveNode(string $n) {return hasType($n, {"bezierCurve"}, true);}proc int isMeshNode(string $n) {return isType($n, {"mesh"}, true);}proc int hasMeshNode(string $n) {return hasType($n, {"mesh"}, true);}proc int isLightNode(string $n) {return isType($n, {"light"}, false);}proc int hasLightNode(string $n) {return hasType($n, {"light"}, false);}proc int isCameraNode(string $n) {return isType($n, {"camera"}, false);}proc int hasCameraNode(string $n) {return hasType($n, {"camera"}, false);}proc int isUUID(string $input) {string $hex = "[A-F0-9]";string $digit4 = $hex + $hex + $hex + $hex;string $digit8 = $digit4 + $digit4;string $digit12 = $digit8 + $digit4;return (isValidString($input,$digit8 + "-" + $digit4 + "-" + $digit4 + "-" + $digit4 + "-" + $digit12));}proc string toShortName(string $path) {string $shortName;if (!`size $path`) return $shortName;string $buffer1[];int $numBuffer1 = `tokenize $path "|" $buffer1`;if ($numBuffer1 > 0) {string $buffer2[];int $numBuffer2 = `tokenize $buffer1[$numBuffer1 - 1] ":" $buffer2`;if ($numBuffer2 > 0) {$shortName = $buffer2[$numBuffer2 - 1];}}return $shortName;}proc string toUUID(string $n) {string $uuid;if (!`objExists $n`) return $uuid;string $uuids[] = `ls -uid $n`;if (`size $uuids` == 1) $uuid = $uuids[0];return $uuid;}proc string uuidToLongName(string $uuid) {string $longName;if (!isUUID($uuid)) return $longName;string $longNames[] = `ls -l $uuid`;if (`size $longNames` == 1) $longName = $longNames[0];return $longName;}proc string setNodeName(string $n, string $name) {if (!`objExists $n` || !`size $name` || isNodeReferenced($n)) return "";string $nodeId = toUUID($n);$n = uuidToLongName($nodeId);rename $n $name;$n = uuidToLongName($nodeId);return $n;}proc string getParentNode(string $n) {if (!`objExists $n`) return "";string $parents[] = `listRelatives -f -p $n`;if (!`size $parents`) return "";return $parents[0];}proc string[] setParentNode(string $nodes[], string $parentNode) {int $toWorld = `size $parentNode` == 0;int $parentIsDagNode = isDagNode($parentNode);if (!$toWorld && !$parentIsDagNode) return $nodes;string $nodeIds[];string $dagNodes[];for ($n in $nodes) {$nodeIds[`size $nodeIds`] = toUUID($n);if (isDagNode($n) && !isNodeReferenced($n)) {$dagNodes[`size $dagNodes`] = $n;}}int $numDagNodes = `size $dagNodes`;if (!$numDagNodes) return $nodes;string $selectedNodes[] = `ls -l -sl`;string $selectedNodeIds[];for ($n in $selectedNodes) {$selectedNodeIds[`size $selectedNodeIds`] = toUUID($n);}if ($numDagNodes) {if ($toWorld) {parent -w $dagNodes;}else if ($parentIsDagNode) {parent -a $dagNodes $parentNode;}}string $newNodes[];for ($id in $nodeIds) {$newNodes[`size $newNodes`] = uuidToLongName($id);}string $newSelectedNodes[];for ($id in $selectedNodeIds) {$newSelectedNodes[`size $newSelectedNodes`] = uuidToLongName($id);}select -r $newSelectedNodes;return $newNodes;}proc string getRootNode(string $n) {string $rootNode;if (!`objExists $n`) return $rootNode;$rootNode = $n;string $parentNode = getParentNode($rootNode);while (`objExists $parentNode`) {$rootNode = $parentNode;$parentNode = getParentNode($rootNode);}return $rootNode;}proc string[] collectRootNodes(string $nodes[]) {string $rootNodes[];if (!`size $nodes`) return $rootNodes;for ($n in $nodes) {string $rootNode = getRootNode($n);if (`objExists $rootNode`) {$rootNodes[`size $rootNodes`] = $rootNode;}}$rootNodes = stringArrayRemoveDuplicates($rootNodes);return $rootNodes;}proc string[] collectChildNodes(string $n) {string $childNodes[];if (!`objExists $n`) return $childNodes;$childNodes = `listRelatives -f -c $n`;return $childNodes;}proc string[] collectDescendantNodes(string $n,string $parentNode,string $types[],int $isExact,string $script) {string $descendantNodes[];if (!`objExists $n`) return $descendantNodes;$n = longNameOf($n);$parentNode = longNameOf($parentNode);string $sourceNode = $n;string $nextNode = $sourceNode;if (`exists $script` && isType($sourceNode, $types, $isExact)) {string $arg1 = "\"" + toUUID($sourceNode) + "\"";string $arg2 = "\"" + toUUID($parentNode) + "\"";string $result[] = `eval $script $arg1 $arg2`;if (`size $result` == 2 && (!`size $result[0]` || isUUID($result[0])) && (!`size $result[1]` || isUUID($result[1]))) {$sourceNode = uuidToLongName($result[0]);$nextNode = uuidToLongName($result[1]);}}if (`objExists $sourceNode`) {$descendantNodes[`size $descendantNodes`] = $sourceNode;}string $childNodes[] = collectChildNodes($nextNode);for ($c in $childNodes) {$descendantNodes = stringArrayCatenate($descendantNodes,collectDescendantNodes($c, $sourceNode, $types, $isExact, $script));}if (`size $types`) {for ($i = `size $descendantNodes` - 1; $i >= 0; $i--) {if (!isType($descendantNodes[$i], $types, $isExact)) {stringArrayRemoveAtIndex($i, $descendantNodes);}}}return $descendantNodes;}proc string[] collectHierarchyNodes(string $nodes[],string $parentNode,string $types[],int $isExact,string $script) {string $hierarchyNodes[];if (!`size $nodes`) return $hierarchyNodes;string $rootNodes[] = collectRootNodes($nodes);for ($n in $rootNodes) {$hierarchyNodes = stringArrayCatenate($hierarchyNodes,collectDescendantNodes($n, $parentNode, $types, $isExact, $script));}$hierarchyNodes = stringArrayRemoveDuplicates($hierarchyNodes);return $hierarchyNodes;}proc string[] gatherNodes(string $types[],int $isExact,int $selectedOnly,string $pattern) {if (!`size $pattern`) $pattern = "::*";string $nodes[];if (`size $types`) {for ($type in $types) {if ($selectedOnly) {if ($isExact) {$nodes = stringArrayCatenate($nodes, `ls -l -sl -et $type $pattern`);}else {$nodes = stringArrayCatenate($nodes, `ls -l -sl -typ $type $pattern`);}}else {if ($isExact) {$nodes = stringArrayCatenate($nodes, `ls -l -et $type $pattern`);}else {$nodes = stringArrayCatenate($nodes, `ls -l -typ $type $pattern`);}}}}else {if ($selectedOnly) {$nodes = `ls -l -sl $pattern`;}else {$nodes = `ls -l $pattern`;}}$nodes = stringArrayRemoveDuplicates($nodes);return $nodes;}proc string nodesAsCSV(string $types[],int $isExact,int $selectedOnly,string $pattern,int $singleNodeOnly) {string $nodes[] = gatherNodes($types, $isExact, $selectedOnly, $pattern);if (`size $nodes` > 1 && $singleNodeOnly) clear $nodes;return stringArrayToString($nodes, ",");}proc string[] csvAsNodes(string $input) {string $nodes[];tokenize $input "," $nodes;if (`size $nodes` == 1 && !`size $nodes[0]`) clear $nodes;return $nodes;}proc string[] getSourceConnectionNodes(string $nodes[],string $types[],int $isExact) {string $tmpNodes[];for ($n in $nodes) {if (!`objExists $n`) continue;$tmpNodes = stringArrayCatenate($tmpNodes,`listConnections -d false -p false -s true $n`);}$tmpNodes = stringArrayRemoveDuplicates($tmpNodes);string $sourceNodes[];for ($i = 0; $i < `size $tmpNodes`; $i++) {string $tmpNode = longNameOf($tmpNodes[$i]);if (isType($tmpNode, $types, $isExact)) {$sourceNodes[`size $sourceNodes`] = $tmpNode;}}$sourceNodes = `sort $sourceNodes`;return $sourceNodes;}proc string[] getDestConnectionNodes(string $nodes[],string $types[],int $isExact) {string $tmpNodes[];for ($n in $nodes) {if (!`objExists $n`) continue;$tmpNodes = stringArrayCatenate($tmpNodes,`listConnections -d true -p false -s false $n`);}$tmpNodes = stringArrayRemoveDuplicates($tmpNodes);string $destNodes[];for ($i = 0; $i < `size $tmpNodes`; $i++) {string $tmpNode = longNameOf($tmpNodes[$i]);if (isType($tmpNode, $types, $isExact)) {$destNodes[`size $destNodes`] = $tmpNode;}}$destNodes = `sort $destNodes`;return $destNodes;}proc string buildDagNode(string $n,string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {if (!isDagNode($n) || isNodeReferenced($n)) return $n;string $nodeId = toUUID($n);$n = uuidToLongName($nodeId);if (isDagNode($matchTransformNode)) {int $numMatchFlags = `size $matchFlags`;if (!`size $matchFlags`) {matchTransform $n $matchTransformNode;}else {if ($matchFlags[0]) matchTransform -pos $n $matchTransformNode;if ($matchFlags[1]) matchTransform -rot $n $matchTransformNode;if ($matchFlags[2]) matchTransform -scl $n $matchTransformNode;}}string $selection[] = `ls -l -sl`;int $shouldSelect = isSelected($n);if ($shouldSelect) {$selection = stringArrayRemove({$n}, $selection);}if (isDagNode($parentNode)) {if ($maintainOffset) {parent -a $n $parentNode;}else {parent -r $n $parentNode;}$n = uuidToLongName($nodeId);}if ($shouldSelect) {$selection[`size $selection`] = $n;}select -r $selection;if (`size $name`) {rename $n $name;$n = uuidToLongName($nodeId);}return $n;}proc string createJoint(string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {return (buildDagNode(longNameOf(`createNode -ss "joint"`),$name,$parentNode,$maintainOffset,$matchTransformNode,$matchFlags));}proc string createLocator(string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {return (buildDagNode(getParentNode(longNameOf(`createNode -ss "locator"`)),$name,$parentNode,$maintainOffset,$matchTransformNode,$matchFlags));}proc string createTransform(string $name,string $parentNode,int $maintainOffset,string $matchTransformNode,int $matchFlags[]) {return (buildDagNode(longNameOf(`createNode -ss "transform"`),$name,$parentNode,$maintainOffset,$matchTransformNode,$matchFlags));}proc string getTopLevelNode(string $topLevelName, int $shouldCreate) {string $n;if (!`size $topLevelName`) return "";string $nodes[] = `ls -l ("::" + $topLevelName)`;int $numNodes = `size $nodes`;if ($numNodes > 1) return "";$n = ($numNodes == 1) ? $nodes[0] : "";if (`objExists $n`) return $n;if ($shouldCreate) {$n = createTransform($topLevelName, "", true, "", {});}return $n;}proc string getSecondLevelNode(string $topLevelName,string $secondLevelName,int $shouldCreate) {string $n;if (!`size $topLevelName` || !`size $secondLevelName`) return "";string $nodes[] = `ls -l ("|::" + $topLevelName + "|::" + $secondLevelName)`;int $numNodes = `size $nodes`;if ($numNodes > 1) return "";$n = ($numNodes == 1) ? $nodes[0] : "";if (`objExists $n`) return $n;if ($shouldCreate) {string $topLevelNode = getTopLevelNode($topLevelName, $shouldCreate);if (!`objExists $topLevelNode`) return "";$n = createTransform($secondLevelName, $topLevelNode, true, "", {});}return $n;}proc string getThirdLevelNode(string $topLevelName,string $secondLevelName,string $thirdLevelName,int $shouldCreate) {string $n;if ( !`size $topLevelName` || !`size $secondLevelName` || !`size $thirdLevelName`) return "";string $nodes[] = `ls -l ("|::" + $topLevelName + "|::" + $secondLevelName + "|::" + $thirdLevelName)`;int $numNodes = `size $nodes`;if ($numNodes > 1) return "";$n = ($numNodes == 1) ? $nodes[0] : "";if (`objExists $n`) return $n;if ($shouldCreate) {string $secondLevelNode = getSecondLevelNode($topLevelName,$secondLevelName,$shouldCreate);if (!`objExists $secondLevelNode`) return "";$n = createTransform($thirdLevelName, $secondLevelNode, true, "", {});}return $n;}proc freezeTransform(string $nodes[], int $preserveFlags[]) {string $dagNodes[];for ($n in $nodes) {if (isDagNode($n)) $dagNodes[`size $dagNodes`] = $n;}if (`size $dagNodes`) {makeIdentity -a true -n 0 -pn true -t (!$preserveFlags[0]) -r (!$preserveFlags[1]) -s (!$preserveFlags[2])$dagNodes;}}
/*1.0.0:Numeric*/proc int isInRangeFloat(float $value, float $min, float $max) {return ($min <= $value && $value <= $max);}proc int isInRangeInt(int $value, int $min, int $max) {return ($min <= $value && $value <= $max);}
/*1.6.0:String*/proc string escapeStringForLiteral(string $input) {string $escapedText;int $size = `size $input`;for ($i = 1; $i <= $size; $i++) {string $c = `substring $input $i $i`;switch ($c) {case "\"": $escapedText += "\\\""; break;case "\\": $escapedText += "\\\\"; break;case "\n": $escapedText += "\\n"; break;case "\r": $escapedText += "\\r"; break;case "\t": $escapedText += "\\t"; break;default: $escapedText += $c; break;}}return $escapedText;}proc string booleanAsStringLiteral(int $value) {return (($value == 0) ? "false" : "true");}proc string floatAsStringLiteral(float $value) {string $literal = (string) $value;if (!`gmatch $literal "*e*"` && !`gmatch $literal "*.*"`) $literal += ".0";return $literal;}proc string intAsStringLiteral(int $value) {return ((string) $value);}proc string stringAsStringLiteral(string $value) {return ("\"" + escapeStringForLiteral($value) + "\"");}proc string booleanArrayAsStringLiteral(int $values[]) {string $stringValues[];for ($i = 0; $i < `size $values`; $i++) {$stringValues[$i] = booleanAsStringLiteral($values[$i]);}return ("{" + stringArrayToString($stringValues, ", ") + "}");}proc string floatArrayAsStringLiteral(float $values[]) {string $stringValues[];for ($i = 0; $i < `size $values`; $i++) {$stringValues[$i] = floatAsStringLiteral($values[$i]);}return ("{" + stringArrayToString($stringValues, ", ") + "}");}proc string intArrayAsStringLiteral(int $values[]) {return ("{" + intArrayToString($values, ", ") + "}");}proc string stringArrayAsStringLiteral(string $values[]) {string $stringValues[];for ($i = 0; $i < `size $values`; $i++) {$stringValues[$i] = stringAsStringLiteral($values[$i]);}return ("{" + stringArrayToString($stringValues, ", ") + "}");}proc string join(string $inputs[], string $separator, int $ignoreEmpty) {int $numInputs = `size $inputs`;if (!$numInputs || ($numInputs == 1 && !`size $inputs[0]`)) return "";if ($ignoreEmpty) {string $buffer[];for ($input in $inputs) {if (`size $input`) $buffer[`size $buffer`] = $input;}return stringArrayToString($buffer, $separator);}else {return stringArrayToString($inputs, $separator);}}proc string strip(string $input) {return `python(convertStringForPythonString($input) + ".strip()")`;}proc string regexSearchGroup(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result = `python("(lambda m: m.group() if m else None)(re.search(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + "))")`;return $result;}proc int[] regexSearchSpan(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");int $result[] = `python("(lambda m: m.span() if m else None)(re.search(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + "))")`;return $result;}proc string[] regexMatchGroups(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result[] = `python("tuple([m.group() for m in re.finditer(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + ")])")`;return $result;}proc string[] regexMatchSubGroups(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result[] = `python("sum([m.groups() for m in re.finditer(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + ")], ())")`;return $result;}proc int[] regexMatchSpans(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");int $result[] = `python("sum([m.span() for m in re.finditer(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + ")], ())")`;return $result;}proc int regexIsMatch(string $pattern, string $input, string $flags) {return (`size (regexSearchGroup($pattern, $input, $flags))` > 0);}proc string[] regexSplit(string $pattern, string $input, string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result[] = `python("tuple(re.split(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($input) + "))")`;return $result;}proc string regexReplace(string $pattern,string $replacement,string $input,string $flags) {$flags = (`size $flags`) ? "(?" + $flags + ")" : "";python("import re");string $result = `python("re.sub(" + convertStringForPythonString($flags + $pattern) + ", " + convertStringForPythonString($replacement) + ", " + convertStringForPythonString($input) + ")")`;return $result;}proc string getClipboardText() {python("from PySide2 import QtGui");return python("QtGui.QClipboard().text()");}proc setClipboardText(string $text) {python("from PySide2 import QtGui");python("QtGui.QClipboard().setText(" + convertStringForPythonString($text) + ")");}proc string dictSanitize(string $input) {string $pattern = "[=;]";if (regexIsMatch($pattern, $input, "")) {return regexReplace($pattern, "_", $input, "");}else {return $input;}}proc string[] dictSanitizeArray(string $input[]) {string $result[];for ($i = 0; $i < `size $input`; $i++) {$result[$i] = dictSanitize($input[$i]);}return $result;}proc string[] dictExtractItems(string $dict) {string $items[];string $buffer[] = regexSplit(";", $dict, "");for ($item in $buffer) {if (!`size $item`) continue;$items[`size $items`] = $item;}return $items;}proc int dictIsKeyEquals(string $item, string $key) {return (`size $key` && `gmatch $item ($key + "=*")`);}proc string dictExtractKey(string $item) {if (!`gmatch $item "?*=*"`) return "";return regexReplace("^([^=]+)=.*", "\\1", $item, "");}proc string dictExtractValue(string $item) {if (!`gmatch $item "?*=*"`) return "";return regexReplace("^[^=]+=", "", $item, "");}proc string dictGetValue(string $dict, string $key) {string $value;if (!`size $key`) return $value;string $items[] = dictExtractItems($dict);for ($item in $items) {if (dictIsKeyEquals($item, $key)) {$value = dictExtractValue($item);break;}}return $value;}proc string[] dictKeys(string $dict) {string $keys[];string $items[] = dictExtractItems($dict);for ($item in $items) {string $key = dictExtractKey($item);if (!`size $key`) continue;$keys[`size $keys`] = $key;}return $keys;}proc int dictContainsKey(string $dict, string $key) {if (!`size $key`) return false;string $keys[] = dictKeys($dict);return stringArrayContains($key, $keys);}proc string dictAddItem(string $dict, string $key, string $value) {if (!`size $key`) return $dict;string $newDict;int $isOverwrite;string $items[] = dictExtractItems($dict);for ($item in $items) {if (dictIsKeyEquals($item, $key)) {$isOverwrite = true;$newDict += $key + "=" + $value + ";";}else {$newDict += $item + ";";}}if (!$isOverwrite) {$newDict += $key + "=" + $value + ";";}return $newDict;}proc string dictAddBoolean(string $dict, string $key, int $value) {return dictAddItem($dict, dictSanitize($key), booleanAsStringLiteral($value));}proc string dictAddFloat(string $dict, string $key, float $value) {return dictAddItem($dict, dictSanitize($key), floatAsStringLiteral($value));}proc string dictAddInt(string $dict, string $key, int $value) {return dictAddItem($dict, dictSanitize($key), intAsStringLiteral($value));}proc string dictAddString(string $dict, string $key, string $value) {$value = dictSanitize($value);return dictAddItem($dict, dictSanitize($key), stringAsStringLiteral($value));}proc string dictAddBooleanArray(string $dict, string $key, int $value[]) {return dictAddItem($dict, dictSanitize($key), booleanArrayAsStringLiteral($value));}proc string dictAddFloatArray(string $dict, string $key, float $value[]) {return dictAddItem($dict, dictSanitize($key), floatArrayAsStringLiteral($value));}proc string dictAddIntArray(string $dict, string $key, int $value[]) {return dictAddItem($dict, dictSanitize($key), intArrayAsStringLiteral($value));}proc string dictAddStringArray(string $dict, string $key, string $value[]) {$value = dictSanitizeArray($value);return dictAddItem($dict, dictSanitize($key), stringArrayAsStringLiteral($value));}proc int dictGetBoolean(string $dict, string $key, int $default) {string $value = dictGetValue($dict, $key);if ($value == "true") {return true;}else if ($value == "false") {return false;}return $default;}proc float dictGetFloat(string $dict, string $key, float $default) {string $value = dictGetValue($dict, $key);if (`size $value`) return ((float) $value);return $default;}proc int dictGetInt(string $dict, string $key, int $default) {string $value = dictGetValue($dict, $key);if (`size $value`) return ((int) $value);return $default;}proc string dictGetString(string $dict, string $key, string $default) {string $value = dictGetValue($dict, $key);if (`size $value`) return `eval ("format -s " + $value + " \"^1s\";")`;return $default;}global int $dictBooleanArrayBuffer[];global float $dictFloatArrayBuffer[];global int $dictIntArrayBuffer[];global string $dictStringArrayBuffer[];proc int[] dictGetBooleanArray(string $dict, string $key, int $default[]) {global int $dictBooleanArrayBuffer[];clear $dictBooleanArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictBooleanArrayBuffer = " + $value + ";");return $dictBooleanArrayBuffer;}return $default;}proc float[] dictGetFloatArray(string $dict, string $key, float $default[]) {global float $dictFloatArrayBuffer[];clear $dictFloatArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictFloatArrayBuffer = " + $value + ";");return $dictFloatArrayBuffer;}return $default;}proc int[] dictGetIntArray(string $dict, string $key, int $default[]) {global int $dictIntArrayBuffer[];clear $dictIntArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictIntArrayBuffer = " + $value + ";");return $dictIntArrayBuffer;}return $default;}proc string[] dictGetStringArray(string $dict, string $key, string $default[]) {global string $dictStringArrayBuffer[];clear $dictStringArrayBuffer;string $value = dictGetValue($dict, $key);if (`size $value`) {eval ("$dictStringArrayBuffer = " + $value + ";");return $dictStringArrayBuffer;}return $default;}proc string dictRemove(string $dict, string $key) {if (!`size $key`) return $dict;string $newDict;string $items[] = dictExtractItems($dict);for ($item in $items) {string $itemKey = dictExtractKey($item);if ($itemKey == $key) continue;$newDict += $item + ";";}return $newDict;}
/*2.1.0:UIControl*/global string $nkUIControls[];proc appendUIControls(string $controls[]) {global string $nkUIControls[];for ($control in $controls) {$nkUIControls[`size $nkUIControls`] = $control;}}proc string getUIControl(string $root, string $end) {global string $nkUIControls[];string $path;for ($control in $nkUIControls) {string $buffer[];int $depth = `tokenize $control "|" $buffer`;string $first = ($depth > 0) ? $buffer[0] : "";string $last = ($depth > 0) ? $buffer[$depth - 1] : "";if ($first == $root && $last == $end) {$path = $control;break;}}return $path;}proc removeUIControls(string $root, string $end) {global string $nkUIControls[];string $paths[];for ($control in $nkUIControls) {string $buffer[];int $depth = `tokenize $control "|" $buffer`;string $first = ($depth > 0) ? $buffer[0] : "";string $last = ($depth > 0) ? $buffer[$depth - 1] : "";int $shouldRemove = (!`size $end`) ? $first == $root : $first == $root && $last == $end;if ($shouldRemove) $paths[`size $paths`] = $control;}if (`size $paths` > 0) {$nkUIControls = stringArrayRemove($paths, $nkUIControls);}}proc string uiControlTypeOf(string $control) {string $type = `objectTypeUI $control`;if ($type == "floatingWindow") $type = "window";return $type;}proc int qEnable(string $control) {string $type = uiControlTypeOf($control);if ($type == "window" || $type == "workspaceControl") return true;return `control -q -en $control`;}proc eEnable(int $bValue, string $control) {string $type = uiControlTypeOf($control);if ($type == "window" || $type == "workspaceControl") return;control -e -en $bValue $control;}proc int qExists(string $control) {return `control -q -ex $control`;}proc int qVisible(string $control) {return `control -q -vis $control`;}proc eVisible(int $bValue, string $control) {control -e -vis $bValue $control;}proc float qFloat(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eFloat(string $type, string $flag, float $fValue, string $control) {eval $type "-e" $flag $fValue $control;}proc int qInt(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eInt(string $type, string $flag, int $iValue, string $control) {eval $type "-e" $flag $iValue $control;}proc string qString(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eString(string $type, string $flag, string $sValue, string $control) {eval $type "-e" $flag ("\"" + $sValue + "\"") $control;}proc float[] qFloatArray(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc int[] qIntArray(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc string[] qStringArray(string $type, string $flag, string $control) {return `eval $type "-q" $flag $control`;}proc eStringArray(string $type, string $flag, string $sValues[], string $control) {for ($sValue in $sValues) {eString($type, $flag, $sValue, $control);}}proc eOrderedFloat(string $type, string $flag, float $fValues[], string $control) {for ($i = 0; $i < `size $fValues`; $i++) {eFloat($type, ($flag + ($i + 1)), $fValues[$i], $control);}}proc eOrderedInt(string $type, string $flag, int $iValues[], string $control) {for ($i = 0; $i < `size $iValues`; $i++) {eInt($type, ($flag + ($i + 1)), $iValues[$i], $control);}}proc eOrderedString(string $type, string $flag, string $sValues[], string $control) {for ($i = 0; $i < `size $sValues`; $i++) {eString($type, ($flag + ($i + 1)), $sValues[$i], $control);}}proc int qIndex(string $type, string $flag, string $control) {return (qInt($type, $flag, $control) - 1);}proc eIndex(string $type, string $flag, int $index, string $control) {eInt($type, $flag, ($index + 1), $control);}proc int[] qIndexArray(string $type, string $flag, string $control) {int $indices[] = qIntArray($type, $flag, $control);for ($i = 0; $i < `size $indices`; $i++) $indices[$i] -= 1;return $indices;}proc eIndexArray(string $type, string $flag, int $indices[], string $control) {for ($i in $indices) {eInt($type, $flag, $i + 1, $control);}}proc int qFirstIndex(string $type, string $flag, string $control) {int $indices[] = qIndexArray($type, $flag, $control);return  ((`size $indices`) ? $indices[0] : -1);}proc string qFirstString(string $type, string $flag, string $control) {string $sValues[] = qStringArray($type, $flag, $control);return  ((`size $sValues`) ? $sValues[0] : "");}proc eIntString(string $type, string $flag, int $iValue, string $sValue, string $control) {eval $type "-e" $flag $iValue ("\"" + $sValue + "\"") $control;}proc eIndexString(string $type, string $flag, int $index, string $sValue, string $control) {eIntString($type, $flag, $index + 1, $sValue, $control);}proc eStringInt(string $type, string $flag, string $sValue, int $iValue, string $control) {eval $type "-e" $flag ("\"" + $sValue + "\"") $iValue $control;}proc executeUIControl(string $type, string $flag, string $control) {eval $type "-e" $flag $control;}proc string getParentableWindow(string $control) {if (uiControlTypeOf($control) == "workspaceControl" && !qInt("workspaceControl", "-fl", $control)) {return "MayaWindow";}else {return $control;}}proc windowClose(string $control) {if (qExists($control)) {string $type = uiControlTypeOf($control);switch ($type) {case "window": deleteUI $control; break;case "workspaceControl": executeUIControl("workspaceControl", "-cl", $control);break;default: break;}}}proc windowPrefRemove(string $type, string $control) {if (qExists($control)) windowClose($control);switch ($type) {case "window": if (qInt("windowPref", "-ex", $control)) {windowPref -r $control;}break;case "workspaceControl": if (qInt("workspaceControlState", "-ex", $control)) {workspaceControlState -r $control;}break;default: break;}}proc string buildWorkspaceControl(string $workspaceControlName,string $label,string $buildProcName,string $buildProcFilename) {string $control = $workspaceControlName;if (!qExists($workspaceControlName)) {string $uiScript = "if (!`exists " + $buildProcName + "`)" + " source \"" + $buildProcFilename + "\"; " + $buildProcName + "();";$control = `workspaceControl -dup false -fl true -l $label -rt false -ui $uiScript$workspaceControlName`;}return $control;}

// /////////////////////////////////////////////////////////////////////////////
// ドメイン
// /////////////////////////////////////////////////////////////////////////////
// -----------------------------------------------------------------------------
// アトリビュート
// -----------------------------------------------------------------------------
/*-
@param $n <string>
@returns <boolean>
*/
proc int hasCurveTransformAttribute(string $n) {
  return (hasShapeTransformAttributes($n) && hasCurveNameAttribute($n));
}

/*-
@param $n <string>
@returns <>
*/
proc addCurveTransformAttribute(string $n) {
  if (!`objExists $n` || hasCurveTransformAttribute($n)) return;
  addShapeTransformAttributes($n);
  addCurveNameAttribute($n);
}

/*-
@param $n <string>
@param $state <boolean>
@returns <>
*/
proc setCurveTransformAttributeLock(string $n, int $state) {
  if (!hasCurveTransformAttribute($n)) return;

  string $attributes[] = {
    "stx", "sty", "stz",
    "srx", "sry", "srz",
    "ssx", "ssy", "ssz"
  };
  for ($attribute in $attributes) {
    setAttributeLock($n, $attribute, $state);
  }
}

/*-
@param $n <string>
@param $state <boolean>
@returns <>
*/
proc setCurveTransformAttributeChannelBox(string $n, int $state) {
  if (!hasCurveTransformAttribute($n)) return;

  string $attributes[] = {
    "stx", "sty", "stz",
    "srx", "sry", "srz",
    "ssx", "ssy", "ssz"
  };
  for ($attribute in $attributes) {
    setAttributeChannelBox($n, $attribute, $state);
  }
}

/*-
@param $n <string>
@param $editMode <boolean>
@returns <>
*/
proc setCurveTransformAttributeState(string $n, int $editMode) {
  setCurveTransformAttributeLock($n, !$editMode);
  setCurveTransformAttributeChannelBox($n, $editMode);
}

/*-
@param $n <string>
@param $state <boolean>
@returns <>
*/
proc setCurveNameAttributeLock(string $n, int $state) {
  if (!hasCurveNameAttribute($n)) return;
  setAttributeLock($n, "cn", $state);
}

/*-
@param $n <string>
@returns <boolean>
*/
proc int hasNurbsCurveAttribute(string $n) {
  return (
    existsAttribute($n, "sourceCurve")
        && `getAttr -typ ($n + ".sourceCurve")` == "nurbsCurve"
  );
}

/*-
@param $n <string>
@returns <>
*/
proc addNurbsCurveAttribute(string $n) {
  if (!`objExists $n` || hasNurbsCurveAttribute($n)) return;
  addAttr -dt "nurbsCurve" -k false -ln "sourceCurve" -sn "sc" $n;
}

// -----------------------------------------------------------------------------
// ノード
// -----------------------------------------------------------------------------
/*-
@param $n <string>
@returns <boolean>
*/
proc int isValidCurveTransform(string $n) {
  return (hasCurveTransformAttribute($n) && `nodeType $n` == "transform");
}

/*-
@param $name <string>
@returns <int>
*/
proc string createCurveTransform(string $name) {
  if (!`size $name`) return "";
  string $n = `createNode -n $name -ss "transform"`;
  addCurveTransformAttribute($n);
  return $n;
}

/*-
@param $n <string>
@returns <int>
*/
proc int isValidNurbsCurve(string $n) {
  return (hasNurbsCurveAttribute($n) && `nodeType $n` == "nurbsCurve");
}

/*-
@param $n <string>
@returns <int>
*/
proc int isEditMode(string $n) {
  if (!isValidCurveTransform($n)) return false;
  string $sources[];
  string $targets[];
  string $nodes[] = getDestConnections(
    $n, {}, "composeMatrix", $sources, $targets
  );
  int $numNodes = `size $nodes`;
  int $numSources = `size $sources`;
  int $numTargets = `size $targets`;
  return ($numNodes > 0 && $numSources > 0 && $numTargets == $numSources);
}

/*-
@param $n <string>
@param $type <string> シェイプノードのタイプ。空文字の場合は全て収集する。
@param $validOnly <boolean> `sourceCurve`アトリビュートを持つノードのみ収集するかどうか。
@returns <string[]>
*/
proc string[] collectShapeNodes(string $n, string $type, int $validOnly) {
  string $shapeNodes[];
  if (`nodeType $n` != "transform") return $shapeNodes;
  string $buffer[] = getShapeNodes($n, "");
  for ($shapeNode in $buffer) {
    if (`size $type` && `nodeType $shapeNode` != $type) continue;
    if ($validOnly && !isValidNurbsCurve($shapeNode)) continue;
    $shapeNodes[`size $shapeNodes`] = $shapeNode;
  }
  return $shapeNodes;
}

/*-
@param $n <string>
@returns <string[]>
*/
proc string[] renameCurveNodes(string $n) {
  string $newCurveNodes[];
  if (!(`objExists $n` && `nodeType $n` == "transform")) return $newCurveNodes;

  string $baseName = shortNameOf($n);
  string $lastCurveNodes[] = collectShapeNodes($n, "nurbsCurve", false);
  for ($i = 0; $i < `size $lastCurveNodes`; $i++) {
    string $shapeName = $baseName + "Shape" + ($i + 1);
    $newCurveNodes[$i] = `rename $lastCurveNodes[$i] $shapeName`;
  }
  return $newCurveNodes;
}

/*-
@param $nodes <string[]>
@returns <>
*/
proc deleteNodes(string $nodes[]) {
  for ($n in $nodes) {
    if (`objExists $n`) delete $n;
  }
}

// -----------------------------------------------------------------------------
// カーブ定義
// -----------------------------------------------------------------------------
/*-
@param $n <string>
@returns <string>
*/
proc string serializeCurve(string $n) {
  // print("serializeCurve\n"); // debug
  // print("  n:" + $n + "\n"); // debug
  string $text;
  if (!(`objExists $n` && `nodeType $n` == "nurbsCurve")) return $text;

  int $d = `getAttr ($n + ".d")`;
  int $s = `getAttr ($n + ".s")`;
  int $f = `getAttr ($n + ".f")`;
  $text += $d + "," + $s + "," + $f + ",0,3";

  string $curveInfoNode = `createNode -ss "curveInfo"`;
  connectAttr ($n + ".ws") ($curveInfoNode + ".ic");
  float $knotValues[] = `getAttr ($curveInfoNode + ".kn")`;
  delete $curveInfoNode;
  $text += "/" + floatArrayToString($knotValues, ",");

  string $cpValues[];
  int $numCVs = $d + $s;
  for ($i = 0; $i < $numCVs; $i++) {
    float $cp[] = `getAttr ($n + ".cp[" + $i + "]")`;
    $cpValues[$i] = floatArrayToString($cp, ",");
  }
  $text += "/" + stringArrayToString($cpValues, ";");
  return $text;
}

/*-
@param $nodes <string[]>
@returns <string>
*/
proc string bundleCurves(string $nodes[]) {
  // print("bundleCurves\n"); // debug
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  string $text;
  if (!`size $nodes`) return $text;

  string $lines[];
  for ($n in $nodes) {
    string $curveNodes[] = collectShapeNodes($n, "nurbsCurve", false);
    // print("  curveNodes    :{\n    " + stringArrayToString($curveNodes, ",\n    ") + "\n  }\n"); // debug
    if (!`size $curveNodes`) continue;

    for ($curveNode in $curveNodes) {
      if (`nodeType $curveNode` != "nurbsCurve") continue;

      // ヒストリを削除しないとCVの値が正しく取得できない
      delete -ch $curveNode;

      string $curveText = serializeCurve($curveNode);
      if (!`size $curveText`) continue;
      $lines[`size $lines`] = $curveText;
    }
  }
  if (!`size $lines`) return $text;

  $text = stringArrayToString($lines, "\n") + "\n";
  return $text;
}

/*-
@param $curveText <string>
@returns <string>
*/
proc string deserializeCurve(string $curveText) {
  // print("deserializeCurve\n"); // debug
  // print("  curveText:" + $curveText + "\n"); // debug
  string $n;
  if (!`size $curveText`) return $n;

  string $createFlags;
  string $sourceCurveValue;

  string $curveBuffer[];
  int $numCurveBuffer = `tokenize $curveText "/" $curveBuffer`;
  // print("  curveBuffer:{\n    " + stringArrayToString($curveBuffer, ",\n    ") + "\n  }\n"); // debug
  if ($numCurveBuffer != 3) return $n;

  string $params[];
  int $numParams = `tokenize $curveBuffer[0] "," $params`;
  // print("  params    :{" + stringArrayToString($params, ", ") + "}\n"); // debug
  if ($numParams != 5) return $n;

  $createFlags += " -d " + $params[0];
  $createFlags += " -os";
  $createFlags += ($params[2] == "2") ? " -per 1" : " -per 0";
  for ($i = 0; $i < $numParams; $i++) {
    $sourceCurveValue += " " + $params[$i];
  }

  string $knotValues[];
  int $numKnotValues = `tokenize $curveBuffer[1] "," $knotValues`;
  // print("  knotValues:{" + stringArrayToString($knotValues, ", ") + "}\n"); // debug
  if (!$numKnotValues) return $n;

  $sourceCurveValue += " " + $numKnotValues;
  for ($i = 0; $i < $numKnotValues; $i++) {
    $createFlags += " -k " + $knotValues[$i];
    $sourceCurveValue += " " + $knotValues[$i];
  }

  string $cvValues[];
  int $numCvValues = `tokenize $curveBuffer[2] ";" $cvValues`;
  // print("  cvValues  :{" + stringArrayToString($cvValues, ", ") + "}\n"); // debug
  if (!$numCvValues) return $n;

  $sourceCurveValue += " " + $numCvValues;
  for ($i = 0; $i < $numCvValues; $i++) {
    string $cvValue[];
    int $numCvValue = `tokenize $cvValues[$i] "," $cvValue`;
    if ($numCvValue != 3) return $n;

    $createFlags += " -p";
    for ($j = 0; $j < $numCvValue; $j++) {
      $createFlags += " " + $cvValue[$j];
      $sourceCurveValue += " " + $cvValue[$j];
    }
  }

  // print("  createFlags     :" + $createFlags + "\n"); // debug
  // print("  sourceCurveValue:" + $sourceCurveValue + "\n"); // debug
  if (!(`size $createFlags` && `size $sourceCurveValue`)) return $n;

  string $createCommand = "curve" + $createFlags;
  // print("  createCommand :" + $createCommand + "\n"); // debug
  $n = `eval $createCommand`;
  // print("  n:" + $n + "\n"); // debug

  if (`objExists $n` && `nodeType $n` == "transform") {
    string $curveNodes[] = collectShapeNodes($n, "nurbsCurve", false);
    if (`size $curveNodes` == 1) {
      string $curveNode = $curveNodes[0];
      addNurbsCurveAttribute($curveNode);
      if (isValidNurbsCurve($curveNode)) {
        string $setAttrCommand = "setAttr \"" + $curveNode + ".sc\"";
        $setAttrCommand += " -typ \"nurbsCurve\"";
        $setAttrCommand += $sourceCurveValue + ";";
        // print("  setAttrCommand:" + $setAttrCommand + "\n"); // debug
        eval $setAttrCommand;
      }
    }
  }
  return $n;
}

// -----------------------------------------------------------------------------
// カーブリスト
// -----------------------------------------------------------------------------
/*-
@returns <string>
*/
proc string getCurveDirname() {
  return (getSourceDirname("nkCurveDepot") + "/nkCurveDepotCurves");
}

/*-
@returns <string>
*/
proc string getTrashDirname() {
  return (getCurveDirname() + "/trash");
}

/*-
@returns <string>
*/
proc string getCurveOrderFilename() {
  string $curveDirname = getCurveDirname();
  if (!existsDirname($curveDirname)) makeDirs($curveDirname);
  if (!existsDirname($curveDirname)) return "";
  return ($curveDirname + "/order.txt");
}

/*-
@returns <string[]>
*/
proc string[] readCurveOrder() {
  // print("readCurveOrder\n"); // debug
  string $order[];
  string $orderFilename = getCurveOrderFilename();
  if (!existsFilename($orderFilename)) return $order;
  $order = readAllLines($orderFilename, "");
  // print("  order:{\n    " + stringArrayToString($order, ",\n    ") + "\n  }\n"); // debug
  return $order;
}

/*-
@param $curveNames <string[]>
@returns <boolean> 成功した場合は`true`、失敗した場合は`false`。
*/
proc int writeCurveOrder(string $curveNames[]) {
  // print("writeCurveOrder\n"); // debug
  // print("  curveNames:{\n    " + stringArrayToString($curveNames, ",\n    ") + "\n  }\n"); // debug
  string $orderFilename = getCurveOrderFilename();
  return (writeAllLines($orderFilename, "", $curveNames));
}

/*-
@returns <boolean> 成功した場合は`true`、失敗した場合は`false`。
*/
proc int sortCurveOrder() {
  // print("sortCurveOrder\n"); // debug
  string $curveOrder[] = readCurveOrder();
  // print("  curveOrder:{\n    " + stringArrayToString($curveOrder, ",\n    ") + "\n  }\n"); // debug
  if (!`size $curveOrder`) return false;

  $curveOrder = `sortCaseInsensitive $curveOrder`;
  if (!writeCurveOrder($curveOrder)) return false;
  return true;
}

/*-
@param $index <int>
@returns <string>
*/
proc string getCurveNameByIndex(int $index) {
  // print("getCurveNameByIndex\n"); // debug
  // print("  index:" + $index + "\n"); // debug
  string $curveName;
  string $curveOrder[] = readCurveOrder();
  // print("  curveOrder:{\n    " + stringArrayToString($curveOrder, ",\n    ") + "\n  }\n"); // debug
  if (!isInRangeInt($index, 0, `size $curveOrder` - 1)) return $curveName;
  return $curveOrder[$index];
}

/*-
@param $curveName <string>
@returns <string>
*/
proc string escapeCurveName(string $curveName) {
  // print("escapeCurveName\n"); // debug
  // print("  curveName:" + $curveName + "\n"); // debug
  if (!isValidFilename($curveName)) {
    $curveName = escapeInvalidFileNameChars($curveName, " ");
  }
  return $curveName;
}

/*-
@param $curveName <string>
@returns <string>
*/
proc string makeCurveFilename(string $curveName) {
  return (getCurveDirname() + "/" + $curveName + ".curvedepot");
}

/*-
@param $curveName <string>
@returns <string>
*/
proc string makeTrashFilename(string $curveName) {
  return (getTrashDirname() + "/" + $curveName + ".curvedepot");
}

/*-
@param $curveName <string>
@param $nodes <string[]>
@returns <boolean> 成功した場合は`true`、失敗した場合は`false`。
*/
proc int addCurve(string $curveName, string $nodes[]) {
  // print("addCurve\n"); // debug
  // print("  curveName:" + $curveName + "\n"); // debug
  $curveName = escapeCurveName($curveName);
  // print("  curveName:" + $curveName + "\n"); // debug
  if (!`size $curveName`) return false;
  if (!`size $nodes`) return false;

  string $curveFilename = makeCurveFilename($curveName);
  string $curveText = bundleCurves($nodes);
  // print("  curveText :" + $curveText + "\n"); // debug
  if (!`size $curveText`) return false;

  string $curveOrder[] = readCurveOrder();
  // print("  curveOrder:{\n    " + stringArrayToString($curveOrder, ",\n    ") + "\n  }\n"); // debug
  if (stringArrayContains($curveName, $curveOrder)) return false;

  if (!writeAllText($curveFilename, "", $curveText)) return false;
  $curveOrder[`size $curveOrder`] = $curveName;
  if (!writeCurveOrder($curveOrder)) return false;
  return true;
}

/*-
@param $index <int> 基数`0`の整数。
@returns <boolean> 成功した場合は`true`、失敗した場合は`false`。
*/
proc int deleteCurve(int $index) {
  // print("deleteCurve\n"); // debug
  // print("  index:" + $index + "\n"); // debug
  string $curveOrder[] = readCurveOrder();
  // print("  curveOrder:{\n    " + stringArrayToString($curveOrder, ",\n    ") + "\n  }\n"); // debug
  if (!isInRangeInt($index, 0, `size $curveOrder` - 1)) return false;

  string $curveName = $curveOrder[$index];
  string $curveFilename = makeCurveFilename($curveName);
  if (!existsFilename($curveFilename)) return false;

  string $trashDirname = getTrashDirname();
  if (!existsDirname($trashDirname)) makeDirs($trashDirname);
  if (existsDirname($trashDirname)) {
    string $trashFilename = makeTrashFilename($curveName);
    if (existsFilename($trashFilename)) deleteFile($trashFilename);
    if (!moveFile($curveFilename, $trashFilename)) return false;
  }

  // 移動に失敗した場合は削除
  if (existsFilename($curveFilename)) {
    if (!deleteFile($curveFilename)) return false;
  }

  if (!stringArrayRemoveAtIndex($index, $curveOrder)) return false;
  if (!writeCurveOrder($curveOrder)) return false;
  return true;
}

/*-
@param $index <int> 基数`0`の整数。
@param $newName <string>
@returns <boolean> 成功した場合は`true`、失敗した場合は`false`。
*/
proc int renameCurve(int $index, string $newName) {
  // print("renameCurve\n"); // debug
  // print("  index  :" + $index + "\n"); // debug
  // print("  newName:" + $newName + "\n"); // debug
  $newName = escapeCurveName($newName);
  // print("  newName:" + $newName + "\n"); // debug
  if (!`size $newName`) return false;

  string $curveOrder[] = readCurveOrder();
  // print("  curveOrder:{\n    " + stringArrayToString($curveOrder, ",\n    ") + "\n  }\n"); // debug
  if (!isInRangeInt($index, 0, `size $curveOrder` - 1)) return false;

  string $lastCurveFilename = makeCurveFilename($curveOrder[$index]);
  string $newCurveFilename = makeCurveFilename($newName);
  // print("  lastCurveFilename:" + $lastCurveFilename + "\n"); // debug
  // print("  newCurveFilename :" + $newCurveFilename + "\n"); // debug
  if (!existsFilename($lastCurveFilename)) return false;
  if (!moveFile($lastCurveFilename, $newCurveFilename)) return false;

  $curveOrder[$index] = $newName;
  if (!writeCurveOrder($curveOrder)) return false;
  return true;
}

/*-
@param $fromIndex <int> 基数`0`の整数。
@returns <boolean> 成功した場合は`true`、失敗した場合は`false`。
*/
proc int movePrevCurve(int $fromIndex) {
  // print("movePrevCurve\n"); // debug
  // print("  fromIndex:" + $fromIndex + "\n"); // debug
  string $curveOrder[] = readCurveOrder();
  // print("  curveOrder:{\n    " + stringArrayToString($curveOrder, ",\n    ") + "\n  }\n"); // debug
  if (!isInRangeInt($fromIndex, 1, `size $curveOrder` - 1)) return false;

  string $curveName = $curveOrder[$fromIndex];
  int $destIndex = $fromIndex - 1;
  if (!stringArrayRemoveAtIndex($fromIndex, $curveOrder)) return false;
  if (!stringArrayInsertAtIndex($destIndex, $curveOrder, $curveName)) return false;
  if (!writeCurveOrder($curveOrder)) return false;
  return true;
}

/*-
@param $fromIndex <int> 基数`0`の整数。
@returns <boolean> 成功した場合は`true`、失敗した場合は`false`。
*/
proc int moveNextCurve(int $fromIndex) {
  // print("moveNextCurve\n"); // debug
  // print("  fromIndex:" + $fromIndex + "\n"); // debug
  string $curveOrder[] = readCurveOrder();
  // print("  curveOrder:{\n    " + stringArrayToString($curveOrder, ",\n    ") + "\n  }\n"); // debug
  if (!isInRangeInt($fromIndex, 0, `size $curveOrder` - 2)) return false;

  string $curveName = $curveOrder[$fromIndex];
  int $destIndex = $fromIndex + 1;
  if (!stringArrayRemoveAtIndex($fromIndex, $curveOrder)) return false;
  if (!stringArrayInsertAtIndex($destIndex, $curveOrder, $curveName)) return false;
  if (!writeCurveOrder($curveOrder)) return false;
  return true;
}

// -----------------------------------------------------------------------------
// カーブ操作
// -----------------------------------------------------------------------------
/*-
@param $curveName <string> カーブ名。
@returns <string> 作成したカーブのトランスフォームノード。
*/
proc string createCurve(string $curveName) {
  // print("createCurve\n"); // debug
  // print("  curveName:" + $curveName + "\n"); // debug
  string $n;
  if (!`size $curveName`) return $n;

  string $curveFilename = makeCurveFilename($curveName);
  if (!existsFilename($curveFilename)) return $n;

  string $lines[] = readAllLines($curveFilename, "");
  if (!`size $lines`) return $n;

  string $curveNodes[];
  string $deletableNodes[];
  for ($line in $lines) {
    string $t = deserializeCurve($line);
    if (!(`objExists $t` && `nodeType $t` == "transform")) continue;
    string $ncs[] = collectShapeNodes($t, "nurbsCurve", true);
    if (!`size $ncs`) continue;
    $curveNodes[`size $curveNodes`] = $ncs[0];
    $deletableNodes[`size $deletableNodes`] = $t;
  }
  if (!`size $curveNodes`) return $n;

  $n = createCurveTransform("nurbsCurve");
  setStringAttribute($n, "cn", $curveName);
  setCurveTransformAttributeState($n, false);
  setCurveNameAttributeLock($n, true);
  if (isValidCurveTransform($n)) {
    parent -r -s $curveNodes $n;
    renameCurveNodes($n);
  }
  if (`size $deletableNodes` > 0) delete $deletableNodes;
  select -r $n;
  return $n;
}

/*-
@param $nodes <string[]>
@returns <string[]> 作成した編集用ノードの配列。
*/
proc string[] buildEditableGraph(string $nodes[]) {
  // print("buildEditableGraph\n"); // debug
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  string $newNodes[];
  if (!`size $nodes`) return $newNodes;

  for ($t in $nodes) {
    // print("  t:" + $t + "\n"); // debug
    if (!isValidCurveTransform($t)) continue;

    setCurveTransformAttributeState($t, true);
    if (isEditMode($t)) continue;

    string $curveNodes[] = collectShapeNodes($t, "nurbsCurve", true);
    // print("    curveNodes:{\n      " + stringArrayToString($curveNodes, ",\n      ") + "\n    }\n"); // debug
    int $numCurveNodes = `size $curveNodes`;
    if (!$numCurveNodes) continue;

    string $tm = `createNode -ss "composeMatrix"`;
    connectAttr -f ($t + ".st") ($tm + ".it");
    connectAttr -f ($t + ".sr") ($tm + ".ir");
    connectAttr -f ($t + ".ss") ($tm + ".is");
    $newNodes[`size $newNodes`] = $tm;

    string $tcm = `createNode -ss "colorMath"`;
    connectAttr -f ($t + ".st") ($tcm + "._ca");
    connectAttr -f ($t + ".rp") ($tcm + "._cb");
    $newNodes[`size $newNodes`] = $tcm;

    for ($i = 0; $i < $numCurveNodes; $i++) {
      string $nc = $curveNodes[$i];
      if (!isValidNurbsCurve($nc)) continue;

      int $d = `getAttr ($nc + ".d")`;
      int $s = `getAttr ($nc + ".s")`;
      int $f = `getAttr ($nc + ".f")`;
      int $numEPs = $s + 1;
      int $numCVs = $d + $s;

      string $ci = `createNode -ss "curveInfo"`;
      connectAttr ($nc + ".sc") ($ci + ".ic");
      $newNodes[`size $newNodes`] = $ci;

      for ($j = 0; $j < $numCVs; $j++) {
        string $civp = `createNode -ss "vectorProduct"`;
        string $cicm = `createNode -ss "colorMath"`;
        $newNodes[`size $newNodes`] = $civp;
        $newNodes[`size $newNodes`] = $cicm;
        setAttr ($civp + ".op") 3;
        setAttr ($cicm + "._cnd") 0;
        connectAttr -f ($ci + ".cp[" + $j + "]") ($civp + ".i1");
        connectAttr -f ($tm + ".omat") ($civp + ".m");
        connectAttr -f ($civp + ".o") ($cicm + "._ca");
        connectAttr -f ($tcm + ".oc") ($cicm + "._cb");
        connectAttr -f ($cicm + ".oc") ($nc + ".cp[" + $j + "]");
      }
    }
  }
  if (`size $newNodes` > 0) dgdirty $newNodes;
  return $newNodes;
}

/*-
@param $nodes <string[]>
@returns <>
*/
proc removeEditableGraph(string $nodes[]) {
  // print("removeEditableGraph\n"); // debug
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  if (!`size $nodes`) return;

  for ($t in $nodes) {
    // print("  t:" + $t + "\n"); // debug
    if (!isValidCurveTransform($t)) continue;

    setCurveTransformAttributeState($t, false);
    if (!isEditMode($t)) continue;

    string $curveNodes[] = collectShapeNodes($t, "nurbsCurve", true);
    // print("    curveNodes:{\n      " + stringArrayToString($curveNodes, ",\n      ") + "\n    }\n"); // debug
    int $numCurveNodes = `size $curveNodes`;
    if (!$numCurveNodes) continue;

    string $tmSources[];
    string $tmTargets[];
    string $tms[] = getDestConnections(
      $t, {}, "composeMatrix", $tmSources, $tmTargets
    );
    // print("    tms:{\n      " + stringArrayToString($tms, ",\n      ") + "\n    }\n"); // debug
    // print("    tmSources:{\n      " + stringArrayToString($tmSources, ",\n      ") + "\n    }\n"); // debug
    // print("    tmTargets:{\n      " + stringArrayToString($tmTargets, ",\n      ") + "\n    }\n"); // debug
    int $numTmSources = `size $tmSources`;
    if (`size $tms` != 1) continue;
    if ($numTmSources != 3) continue;
    if (`size $tmTargets` != $numTmSources) continue;

    string $tmvpSources[];
    string $tmvpTargets[];
    string $tmvps[] = getDestConnections(
      $tms[0], {}, "vectorProduct", $tmvpSources, $tmvpTargets
    );
    // print("    tmvps:{\n      " + stringArrayToString($tmvps, ",\n      ") + "\n    }\n"); // debug
    // print("    tmvpSources:{\n      " + stringArrayToString($tmvpSources, ",\n      ") + "\n    }\n"); // debug
    // print("    tmvpTargets:{\n      " + stringArrayToString($tmvpTargets, ",\n      ") + "\n    }\n"); // debug
    int $numTmvpSources = `size $tmvpSources`;
    if (!`size $tmvps`) continue;
    if (!$numTmvpSources) continue;
    if (`size $tmvpTargets` != $numTmvpSources) continue;

    string $tcmSources[];
    string $tcmTargets[];
    string $tcms[] = getDestConnections(
      $t, {}, "colorMath", $tcmSources, $tcmTargets
    );
    // print("    tcms:{\n      " + stringArrayToString($tcms, ",\n      ") + "\n    }\n"); // debug
    // print("    tcmSources:{\n      " + stringArrayToString($tcmSources, ",\n      ") + "\n    }\n"); // debug
    // print("    tcmTargets:{\n      " + stringArrayToString($tcmTargets, ",\n      ") + "\n    }\n"); // debug
    int $numTcmSources = `size $tcmSources`;
    if (`size $tcms` != 1) continue;
    if ($numTcmSources != 2) continue;
    if (`size $tcmTargets` != $numTcmSources) continue;

    string $tcmcmSources[];
    string $tcmcmTargets[];
    string $tcmcms[] = getDestConnections(
      $tcms[0], {}, "colorMath", $tcmcmSources, $tcmcmTargets
    );
    // print("    tcmcms:{\n      " + stringArrayToString($tcmcms, ",\n      ") + "\n    }\n"); // debug
    // print("    tcmcmSources:{\n      " + stringArrayToString($tcmcmSources, ",\n      ") + "\n    }\n"); // debug
    // print("    tcmcmTargets:{\n      " + stringArrayToString($tcmcmTargets, ",\n      ") + "\n    }\n"); // debug
    int $numTcmcmSources = `size $tcmcmSources`;
    if (!`size $tcmcms`) continue;
    if (!$numTcmcmSources) continue;
    if (`size $tcmcmTargets` != $numTcmcmSources) continue;

    disconnectAttributes($tmSources, $tmTargets);
    disconnectAttributes($tmvpSources, $tmvpTargets);
    disconnectAttributes($tcmSources, $tcmTargets);
    disconnectAttributes($tcmcmSources, $tcmcmTargets);
    deleteNodes($tms);
    deleteNodes($tcms);

    for ($i = 0; $i < $numCurveNodes; $i++) {
      string $nc = $curveNodes[$i];
      // print("    nc:" + $nc + "\n"); // debug
      if (!isValidNurbsCurve($nc)) continue;

      int $d = `getAttr ($nc + ".d")`;
      int $s = `getAttr ($nc + ".s")`;
      int $numCVs = $d + $s;

      string $cicmSources[];
      string $cicmTargets[];
      string $cicms[] = getSourceConnections(
        $nc, {}, "colorMath", $cicmSources, $cicmTargets
      );
      // print("      cicms:{\n        " + stringArrayToString($cicms, ",\n        ") + "\n      }\n"); // debug
      // print("      cicmSources:{\n        " + stringArrayToString($cicmSources, ",\n        ") + "\n      }\n"); // debug
      // print("      cicmTargets:{\n        " + stringArrayToString($cicmTargets, ",\n        ") + "\n      }\n"); // debug
      int $numCicmSources = `size $cicmSources`;
      if (`size $cicms` != $numCVs) continue;
      if ($numCicmSources != $numCVs) continue;
      if (`size $cicmTargets` != $numCicmSources) continue;

      disconnectAttributes($cicmSources, $cicmTargets);

      string $ciSources[];
      string $ciTargets[];
      string $cis[] = getDestConnections(
        $nc, {}, "curveInfo", $ciSources, $ciTargets
      );
      // print("      cis:{\n        " + stringArrayToString($cis, ",\n        ") + "\n      }\n"); // debug
      // print("      ciSources:{\n        " + stringArrayToString($ciSources, ",\n        ") + "\n      }\n"); // debug
      // print("      ciTargets:{\n        " + stringArrayToString($ciTargets, ",\n        ") + "\n      }\n"); // debug
      int $numCiSources = `size $ciSources`;
      if (`size $cis` != 1) continue;
      if ($numCiSources != 1) continue;
      if (`size $ciTargets` != $numCiSources) continue;

      string $civpSources[];
      string $civpTargets[];
      string $civps[] = getDestConnections(
        $cis[0], {}, "vectorProduct", $civpSources, $civpTargets
      );
      // print("      civps:{\n        " + stringArrayToString($civps, ",\n        ") + "\n      }\n"); // debug
      // print("      civpSources:{\n        " + stringArrayToString($civpSources, ",\n        ") + "\n      }\n"); // debug
      // print("      civpTargets:{\n        " + stringArrayToString($civpTargets, ",\n        ") + "\n      }\n"); // debug
      int $numCivpSources = `size $civpSources`;
      if (`size $civps` != $numCVs) continue;
      if ($numCivpSources != $numCVs) continue;
      if (`size $civpTargets` != $numCivpSources) continue;

      // vectorProductへの接続を先に切る
      disconnectAttributes($civpSources, $civpTargets);

      // 接続を切らずに削除
      // disconnectAttributes($ciSources, $ciTargets);
      deleteNodes($cis);

      deleteNodes($civps);
      deleteNodes($cicms);
    }
  }
}

/*-
@param $nodes <string[]> ノードの配列。
@param $state <boolean> ロック状態。
@returns <>
*/
proc lockCurve(string $nodes[], int $state) {
  if ($state) {
    removeEditableGraph($nodes);
  }
  else {
    buildEditableGraph($nodes);
  }
  refresh;
}

/*-
@param $nodes <string[]> 1番目要素がソースノード、2番目要素がターゲットノードの配列。
@returns <string[]> 新たに置き換えられたシェイプノードの配列。
*/
proc string[] replaceCurves(string $nodes[]) {
  // print("replaceCurves\n"); // debug
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  string $newNodes[];
  if (`size $nodes` != 2) return $newNodes;

  string $sourceNode = $nodes[0];
  string $targetNode = $nodes[1];
  // print("  sourceNode:" + $sourceNode + "\n"); // debug
  // print("  targetNode:" + $targetNode + "\n"); // debug
  // if (!(
  if (
    !isValidCurveTransform($sourceNode)
        || !`objExists $targetNode`
        || `nodeType $targetNode` != "transform"
  ) return $newNodes;

  if (isEditMode($sourceNode)) removeEditableGraph({$sourceNode});
  if (isEditMode($sourceNode)) return $newNodes;

  if (isValidCurveTransform($targetNode)) {
    if (isEditMode($targetNode)) removeEditableGraph({$targetNode});
    if (isEditMode($targetNode)) return $newNodes;
  }
  else {
    addCurveTransformAttribute($targetNode);
  }
  if (!isValidCurveTransform($targetNode)) return $newNodes;

  setCurveNameAttributeLock($targetNode, false);
  setStringAttribute(
    $targetNode,
    "cn",
    getStringAttribute($sourceNode, "cn", "")
  );
  setCurveNameAttributeLock($targetNode, true);

  // 念のためヒストリを削除しておく
  delete -ch $targetNode;

  string $sourceCurveNodes[] = collectShapeNodes($sourceNode, "nurbsCurve", true);
  // print("  sourceCurveNodes:{\n    " + stringArrayToString($sourceCurveNodes, ",\n    ") + "\n  }\n"); // debug
  if (!`size $sourceCurveNodes`) return $newNodes;

  string $targetShapeNodes[] = collectShapeNodes($targetNode, "", false);
  // print("  targetShapeNodes:{\n    " + stringArrayToString($targetShapeNodes, ",\n    ") + "\n  }\n"); // debug

  if (`size $targetShapeNodes`) deleteNodes($targetShapeNodes);

  parent -r -s $sourceCurveNodes $targetNode;
  $newNodes = renameCurveNodes($targetNode);
  if (`objExists $sourceNode`) delete $sourceNode;

  // ピボットのオフセットを反映させる
  buildEditableGraph({$targetNode});
  dgdirty $targetNode;
  refresh;
  removeEditableGraph({$targetNode});
  select -r $targetNode;
  return $newNodes;
}

// /////////////////////////////////////////////////////////////////////////////
// API
// /////////////////////////////////////////////////////////////////////////////
/*-
@param $curveName <string> カーブ名。
@returns <string> 作成したカーブのトランスフォームノード。
*/
global proc string nkCurveDepot.CreateCurve(string $curveName) {
  return createCurve($curveName);
}

/*-
@param $nodes <string[]> ノードの配列。
@param $state <boolean> ロック状態。
@returns <>
*/
global proc nkCurveDepot.LockCurve(string $nodes[], int $state) {
  lockCurve($nodes, $state);
}

/*-
@param $nodes <string[2]> 1番目要素がソースノード、2番目要素がターゲットノードの配列。
@returns <string[]> 新たに置き換えられたシェイプノードの配列。
*/
global proc string[] nkCurveDepot.ReplaceCurves(string $nodes[]) {
  return replaceCurves($nodes);
}

// /////////////////////////////////////////////////////////////////////////////
// スクリプトジョブ
// /////////////////////////////////////////////////////////////////////////////
// -----------------------------------------------------------------------------
// イベントジョブ
// -----------------------------------------------------------------------------
// /*-
// @returns <>
// */
// proc registerEventJob() {
//   print("registerEventJob\n"); // debug
// }

// /*-
// @returns <>
// */
// proc unregisterEventJob() {
//   print("unregisterEventJob\n"); // debug
// }

// /////////////////////////////////////////////////////////////////////////////
// プレゼンテーション
// /////////////////////////////////////////////////////////////////////////////
/*-
@param $initCurveName <string>
@returns <string>
*/
proc string makeCurveName(string $initCurveName) {
  string $result = `promptDialog
      -b "OK" -db "OK"
      -b "Cancel"-cb "Cancel"
      -m "Enter Curve Name:"
      -t "Curve Name"
      -tx $initCurveName`;
  if ($result != "OK") return $initCurveName;
  return `promptDialog -q -tx`;
}

/*-
@returns <int>
*/
proc int getCurveListSelectedIndex() {
  string $curveList = getUIControl("nkCurveDepotWindow", "curveList");
  return (qFirstIndex("textScrollList", "-sii", $curveList));
}

/*-
@returns <string>
*/
proc string getCurveListSelectedItem() {
  string $curveList = getUIControl("nkCurveDepotWindow", "curveList");
  return (qFirstString("textScrollList", "-si", $curveList));
}

/*-
@param $index <int>
@returns <>
*/
proc selectCurveListByIndex(int $index) {
  string $curveList = getUIControl("nkCurveDepotWindow", "curveList");
  executeUIControl("textScrollList", "-da", $curveList);
  int $numItems = qInt("textScrollList", "-ni", $curveList);
  if (!isInRangeInt($index, 0, $numItems - 1)) return;
  eIndex("textScrollList", "-sii", $index, $curveList);
}

/*-
@param $item <string>
@returns <>
*/
proc selectCurveListByItem(string $item) {
  if (!`size $item`) return;
  string $curveList = getUIControl("nkCurveDepotWindow", "curveList");
  executeUIControl("textScrollList", "-da", $curveList);
  int $numItems = qInt("textScrollList", "-ni", $curveList);
  if (!$numItems) return;
  eStringArray("textScrollList", "-si", {$item}, $curveList);
}

/*-
@param $selectionMode <string> 更新後の選択状態。
| 値          | 説明                             |
| ----------- | -------------------------------- |
| `none`      | 選択無し                         |
| `keepIndex` | 前回の選択インデックスを引き継ぐ |
| `keepItem`  | 前回の選択アイテムを引き継ぐ     |
| `last`      | 末尾のアイテムを選択             |
| `prev`      | 前に一つずらす                   |
| `next`      | 後に一つずらす                   |
@returns <>
*/
proc updateCurveList(string $selectionMode) {
  // print("updateCurveList\n"); // debug
  // print("  selectionMode:" + $selectionMode + "\n"); // debug

  int $lastIndex = getCurveListSelectedIndex();
  string $lastItem = getCurveListSelectedItem();
  // print("  lastIndex:" + $lastIndex + "\n"); // debug
  // print("  lastItem :" + $lastItem + "\n"); // debug

  string $curveList = getUIControl("nkCurveDepotWindow", "curveList");
  executeUIControl("textScrollList", "-ra", $curveList);

  string $curveOrder[] = readCurveOrder();
  // print("  curveOrder:{\n    " + stringArrayToString($curveOrder, ",\n    ") + "\n  }\n"); // debug
  for ($curveName in $curveOrder) {
    eString("textScrollList", "-a", $curveName, $curveList);
  }

  switch ($selectionMode) {
    case "none": selectCurveListByIndex(-1); break;
    case "keepIndex": selectCurveListByIndex($lastIndex); break;
    case "keepItem": selectCurveListByItem($lastItem); break;
    case "last": selectCurveListByIndex(`size $curveOrder` - 1); break;
    case "prev": selectCurveListByIndex($lastIndex - 1); break;
    case "next": selectCurveListByIndex($lastIndex + 1); break;
    default: break;
  }
}

// -----------------------------------------------------------------------------
// UIコントロールイベントハンドラ
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
proc nkCurveDepotWindowClosed() {
  // print("nkCurveDepotWindowClosed\n"); // debug
  removeUIControls("nkCurveDepotWindow", "");
}

/*-
@returns <>
*/
proc resetWindowMenuItemSelected() {
  // print("resetWindowMenuItemSelected\n"); // debug
  windowPrefRemove("window", "nkCurveDepotWindow");
  nkCurveDepot();
}

/*-
@returns <>
*/
proc quitMenuItemSelected() {
  // print("quitMenuItemSelected\n"); // debug
  string $nkCurveDepotWindow = getUIControl("nkCurveDepotWindow", "nkCurveDepotWindow");
  // print("  nkCurveDepotWindow:" + $nkCurveDepotWindow + "\n"); // debug
  windowClose($nkCurveDepotWindow);
}

/*-
@returns <>
*/
proc aboutMenuItemSelected() {
  // print("aboutMenuItemSelected\n"); // debug
  confirmDialog
      -b "OK"
      -db "OK"
      -m (
        "nkCurveDepot " + (nkCurveDepotVersion())
            + "\n\nMIT License\nhttps://github.com/imaoki/nkCurveDepot"
      )
      -p (getParentableWindow("nkCurveDepotWindow"))
      -t "About - nkCurveDepot";
}

/*-
@returns <>
*/
proc addButtonPressed() {
  // print("addButtonPressed\n"); // debug
  string $nodes[] = `ls -l -sl -tr`;
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  if (!`size $nodes`) return;

  string $curveName = makeCurveName("");
  // print ("  curveName:" + $curveName + "\n"); // debug
  if (!`size $curveName`) return;

  if (addCurve($curveName, $nodes)) updateCurveList("last");
}

/*-
@returns <>
*/
proc renameButtonPressed() {
  // print("renameButtonPressed\n"); // debug
  int $index = getCurveListSelectedIndex();
  // print("  index:" + $index + "\n"); // debug

  string $curveName = getCurveNameByIndex($index);
  // print ("  curveName:\"" + $curveName + "\"\n"); // debug
  if (!`size $curveName`) return;

  $curveName = makeCurveName($curveName);
  // print ("  curveName:" + $curveName + "\n"); // debug
  if (!`size $curveName`) return;

  if (renameCurve($index, $curveName)) updateCurveList("keepIndex");
}

/*-
@returns <>
*/
proc createButtonPressed() {
  // print("createButtonPressed\n"); // debug
  int $index = getCurveListSelectedIndex();
  // print("  index:" + $index + "\n"); // debug
  string $curveName = getCurveNameByIndex($index);
  // print ("  curveName:" + $curveName + "\n"); // debug
  if (!`size $curveName`) return;
  string $n = createCurve($curveName);
  if (`objExists $n`) select -r $n;
}

/*-
@returns <>
*/
proc unlockButtonPressed() {
  // print("unlockButtonPressed\n"); // debug
  string $nodes[] = `ls -l -sl -tr`;
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  if (!`size $nodes`) return;
  lockCurve($nodes, false);
}

/*-
@returns <>
*/
proc lockButtonPressed() {
  // print("lockButtonPressed\n"); // debug
  string $nodes[] = `ls -l -sl -tr`;
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  if (!`size $nodes`) return;
  lockCurve($nodes, true);
}

/*-
@returns <>
*/
proc replaceButtonPressed() {
  // print("replaceButtonPressed\n"); // debug
  string $nodes[] = `ls -l -sl -tr`;
  // print("  nodes:{\n    " + stringArrayToString($nodes, ",\n    ") + "\n  }\n"); // debug
  if (!`size $nodes`) return;
  replaceCurves($nodes);
}

/*-
@returns <>
*/
proc curveListDoubleClicked() {
  // print("curveListDoubleClicked\n"); // debug
  createButtonPressed();
}

/*-
@returns <>
*/
proc deleteButtonPressed() {
  // print("deleteButtonPressed\n"); // debug
  int $index = getCurveListSelectedIndex();
  // print("  index:" + $index + "\n"); // debug
  if ($index < 0) return;

  string $result = `confirmDialog
      -b "OK" -db "OK"
      -b "Cancel"-cb "Cancel"
      -m "Are you sure?\n\nDeleted curves are moved to nkCurveDepotCurves/trash."
      -t "Delete Curve"`;
  if ($result != "OK") return;

  if (deleteCurve($index)) updateCurveList("keepIndex");
}

/*-
@returns <>
*/
proc moveUpButtonPressed() {
  // print("moveUpButtonPressed\n"); // debug
  int $index = getCurveListSelectedIndex();
  // print("  index:" + $index + "\n"); // debug
  if (movePrevCurve($index)) updateCurveList("prev");
}

/*-
@returns <>
*/
proc moveDownButtonPressed() {
  // print("moveDownButtonPressed\n"); // debug
  int $index = getCurveListSelectedIndex();
  // print("  index:" + $index + "\n"); // debug
  if (moveNextCurve($index)) updateCurveList("next");
}

/*-
@returns <>
*/
proc sortButtonPressed() {
  // print("sortButtonPressed\n"); // debug
  if (sortCurveOrder()) updateCurveList("keepItem");
}

// -----------------------------------------------------------------------------
// ウィンドウ定義
// -----------------------------------------------------------------------------
/*-
@returns <>
*/
proc buildMainWindow() {
  // print("buildMainWindow\n"); // debug
  windowClose("nkCurveDepotWindow");

  string $nkCurveDepotWindow = `window
      -mxb false
      -mnb false
      -s true
      -t "nkCurveDepot"
      "nkCurveDepotWindow"`;
    string $outerForm = `formLayout "outerForm"`;
      string $menuBar = `menuBarLayout
          // -bgc 0.25 0.5 0.25
          "menuBar"`;
        string $fileMenu = `menu
            -l "File"
            "fileMenu"`;
          string $resetWindowMenuItem = `menuItem
              -l "Reset Window"
              "resetWindowMenuItem"`;
          menuItem -d true;
          string $quitMenuItem = `menuItem
              -l "Quit"
              "quitMenuItem"`;
        string $helpMenu = `menu
            -hm true
            -l "Help"
            "helpMenu"`;
          string $aboutMenuItem = `menuItem
              -l "About nkCurveDepot"
              "aboutMenuItem"`;
      setParent ..;

      string $topToolRow = `rowLayout
          -adj 10
          // -bgc 0.5 0.25 0.25
          -nc 10
          "topToolRow"`;
        string $addButton = `iconTextButton
            -ann "Add Curve"
            // -bgc 0.25 0.5 0.5
            -i "item_add.png"
            -w 23
            "addButton"`;
        string $renameButton = `iconTextButton
            -ann "Rename Curve"
            // -bgc 0.25 0.5 0.5
            -i "passSetRelationEditor.png"
            -w 23
            "renameButton"`;
        separator -h 24 -st "single" -vis true;
        string $createButton = `iconTextButton
            -ann "Create Curve"
            // -bgc 0.25 0.5 0.5
            -i "createNode.png"
            -w 23
            "createButton"`;
        separator -h 24 -st "single" -vis true;
        string $unlockButton = `iconTextButton
            -ann "Unlock Shape Transform"
            // -bgc 0.25 0.5 0.5
            -i "unlockGeneric.png"
            -w 23
            "unlockButton"`;
        string $lockButton = `iconTextButton
            -ann "Lock Shape Transform"
            // -bgc 0.25 0.5 0.5
            -i "lockGeneric.png"
            -w 23
            "lockButton"`;
        separator -h 24 -st "single" -vis true;
        string $replaceButton = `iconTextButton
            -ann "Replace Curve\n\n1. Select source transform node\n2. Select target transform node"
            // -bgc 0.25 0.5 0.5
            -i "bufferSnap.png"
            -w 23
            "replaceButton"`;
        separator -st "none" -vis false;
      setParent ..;

      string $curveList = `textScrollList
          -ams false
          -ekf false
          -h 31
          "curveList"`;

      string $bottomToolRow = `rowLayout
          -adj 2
          // -bgc 0.5 0.25 0.25
          -nc 5
          "bottomToolRow"`;
        string $deleteButton = `iconTextButton
            -ann "Delete Curve"
            // -bgc 0.25 0.5 0.5
            -i "item_delete.png"
            -w 23
            "deleteButton"`;
        separator -st "none" -vis false;
        string $moveUpButton = `iconTextButton
            -ann "Move Curve Up"
            // -bgc 0.25 0.5 0.5
            -i "item_up.png"
            -w 23
            "moveUpButton"`;
        string $moveDownButton = `iconTextButton
            -ann "Move Curve Down"
            // -bgc 0.25 0.5 0.5
            -i "item_down.png"
            -w 23
            "moveDownButton"`;
        string $sortButton = `iconTextButton
            -ann "Sort by ascending order"
            // -bgc 0.25 0.5 0.5
            -i "sortName.png"
            -w 23
            "sortButton"`;
      setParent ..;

    setParent ..;

  formLayout -e
      -af $menuBar "top" 0
      -af $menuBar "left" 0
      -af $menuBar "right" 0
      -ac $topToolRow "top" 0 $menuBar
      -af $topToolRow "left" 5
      -af $topToolRow "right" 5
      -ac $curveList "top" 5 $topToolRow
      -af $curveList "left" 5
      -af $curveList "right" 5
      -ac $curveList "bottom" 5 $bottomToolRow
      -af $bottomToolRow "left" 5
      -af $bottomToolRow "right" 5
      -af $bottomToolRow "bottom" 5
      $outerForm;

  window -e -cc "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"cc\", \"nkCurveDepotWindow\");" $nkCurveDepotWindow;
  menuItem -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"resetWindowMenuItem\");" $resetWindowMenuItem;
  menuItem -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"quitMenuItem\");" $quitMenuItem;
  menuItem -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"aboutMenuItem\");" $aboutMenuItem;

  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"addButton\");" $addButton;
  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"renameButton\");" $renameButton;
  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"createButton\");" $createButton;
  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"unlockButton\");" $unlockButton;
  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"lockButton\");" $lockButton;
  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"replaceButton\");" $replaceButton;
  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"deleteButton\");" $deleteButton;
  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"moveUpButton\");" $moveUpButton;
  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"moveDownButton\");" $moveDownButton;
  iconTextButton -e -c "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"c\", \"sortButton\");" $sortButton;

  textScrollList -e -dcc "nkCurveDepotEventController(\"nkCurveDepotWindow\", \"dcc\", \"curveList\");" $curveList;

  appendUIControls({
    $nkCurveDepotWindow,
    $curveList
  });

  updateCurveList("none");
  showWindow $nkCurveDepotWindow;
}

// -----------------------------------------------------------------------------
// イベントコントローラ
// -----------------------------------------------------------------------------
/*-
@param $window <string>
@param $event <string>
@param $control <string>
@returns <>
*/
global proc nkCurveDepotEventController(
  string $window,
  string $event,
  string $control
) {
  // print("nkCurveDepotEventController\n"); // debug
  // print("  window :" + $window + "\n"); // debug
  // print("  event  :" + $event + "\n"); // debug
  // print("  control:" + $control + "\n"); // debug
  switch ($window) {
    case "nkCurveDepotWindow":
      switch ($event) {
        case "c":
          switch ($control) {
            case "resetWindowMenuItem": resetWindowMenuItemSelected(); break;
            case "quitMenuItem": quitMenuItemSelected(); break;
            case "aboutMenuItem": aboutMenuItemSelected(); break;

            case "addButton": addButtonPressed(); break;
            case "renameButton": renameButtonPressed(); break;
            case "createButton": createButtonPressed(); break;
            case "unlockButton": unlockButtonPressed(); break;
            case "lockButton": lockButtonPressed(); break;
            case "replaceButton": replaceButtonPressed(); break;
            case "deleteButton": deleteButtonPressed(); break;
            case "moveUpButton": moveUpButtonPressed(); break;
            case "moveDownButton": moveDownButtonPressed(); break;
            case "sortButton": sortButtonPressed(); break;
            default: break;
          }
          break;
        case "cc":
          switch ($control) {
            case "nkCurveDepotWindow": nkCurveDepotWindowClosed(); break;
            default: break;
          }
          break;
        case "dcc":
          switch ($control) {
            case "curveList": curveListDoubleClicked(); break;
            default: break;
          }
          break;
        default: break;
      }
      break;
    default: break;
  }
}

// -----------------------------------------------------------------------------
// ドメインオブザーバ
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// イベントオブザーバ
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// メイン
// -----------------------------------------------------------------------------
/*-
@returns <string>
*/
global proc string nkCurveDepotVersion() {
  return "1.2.5";
}

/*-
@returns <>
*/
global proc nkCurveDepot() {
  buildMainWindow();
}

/*
eval ("source \"" + `getenv "MAYA_APP_DIR"` + "/dev/nkCurveDepot/nkCurveDepot.mel\"");
nkCurveDepot;
*/

// /////////////////////////////////////////////////////////////////////////////
// テスト
// /////////////////////////////////////////////////////////////////////////////
/*-
@returns <>
@remarks アトリビュート。
*/
proc test0() {
  print("test0 start\n");
  string $r;

  // hasCurveTransformAttribute / addCurveTransformAttribute
  {
    string $t1 = `createNode -ss "transform"`;
    $r = assertFalse(hasCurveTransformAttribute("")); if (`size $r`) warning $r;
    $r = assertFalse(hasCurveTransformAttribute($t1)); if (`size $r`) warning $r;
    addCurveTransformAttribute($t1);
    $r = assertTrue(hasCurveTransformAttribute($t1)); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0}, `getAttr ($t1 + ".st")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0}, `getAttr ($t1 + ".sr")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({1.0, 1.0, 1.0}, `getAttr ($t1 + ".ss")`, 0.001); if (`size $r`) warning $r;
    if (`objExists $t1`) delete $t1;
  }

  // setCurveTransformAttributeLock / setCurveTransformAttributeChannelBox / setCurveTransformAttributeState
  {
    string $t1 = `createNode -ss "transform"`;
    string $stx = $t1 + ".stx";
    string $sty = $t1 + ".sty";
    string $stz = $t1 + ".stz";
    string $srx = $t1 + ".srx";
    string $sry = $t1 + ".sry";
    string $srz = $t1 + ".srz";
    string $ssx = $t1 + ".ssx";
    string $ssy = $t1 + ".ssy";
    string $ssz = $t1 + ".ssz";

    $r = assertFalse(hasCurveTransformAttribute($t1)); if (`size $r`) warning $r;
    addCurveTransformAttribute($t1);
    $r = assertTrue(hasCurveTransformAttribute($t1)); if (`size $r`) warning $r;

    $r = assertFalse(`getAttr -l $stx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $sty`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $stz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $srx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $sry`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $srz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $ssx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $ssy`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $ssz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $stx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $sty`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $stz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $srx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $sry`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $srz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssy`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssz`); if (`size $r`) warning $r;

    setCurveTransformAttributeLock($t1, true);
    $r = assertTrue(`getAttr -l $stx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $sty`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $stz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $srx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $sry`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $srz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $ssx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $ssy`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $ssz`); if (`size $r`) warning $r;
    setCurveTransformAttributeLock($t1, false);
    $r = assertFalse(`getAttr -l $stx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $sty`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $stz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $srx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $sry`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $srz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $ssx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $ssy`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $ssz`); if (`size $r`) warning $r;

    setCurveTransformAttributeChannelBox($t1, true);
    $r = assertTrue(`getAttr -cb $stx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $sty`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $stz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $srx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $sry`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $srz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $ssx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $ssy`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $ssz`); if (`size $r`) warning $r;
    setCurveTransformAttributeChannelBox($t1, false);
    $r = assertFalse(`getAttr -cb $stx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $sty`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $stz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $srx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $sry`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $srz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssy`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssz`); if (`size $r`) warning $r;

    setCurveTransformAttributeState($t1, true);
    $r = assertFalse(`getAttr -l $stx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $sty`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $stz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $srx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $sry`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $srz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $ssx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $ssy`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l $ssz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $stx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $sty`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $stz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $srx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $sry`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $srz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $ssx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $ssy`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -cb $ssz`); if (`size $r`) warning $r;

    setCurveTransformAttributeState($t1, false);
    $r = assertTrue(`getAttr -l $stx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $sty`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $stz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $srx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $sry`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $srz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $ssx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $ssy`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $ssz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $stx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $sty`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $stz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $srx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $sry`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $srz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssy`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssz`); if (`size $r`) warning $r;

    if (`objExists $t1`) delete $t1;
  }

  // setCurveNameAttributeLock
  {
    string $t1 = `createNode -ss "transform"`;
    addCurveNameAttribute($t1);
    $r = assertTrue(hasCurveNameAttribute($t1)); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -l ($t1 + ".cn")`); if (`size $r`) warning $r;
    setCurveNameAttributeLock($t1, true);
    $r = assertTrue(`getAttr -l ($t1 + ".cn")`); if (`size $r`) warning $r;
    if (`objExists $t1`) delete $t1;
  }

  // hasNurbsCurveAttribute / addNurbsCurveAttribute
  {
    string $t1 = `createNode -ss "transform"`;
    $r = assertFalse(hasNurbsCurveAttribute("")); if (`size $r`) warning $r;
    $r = assertFalse(hasNurbsCurveAttribute($t1)); if (`size $r`) warning $r;
    addNurbsCurveAttribute($t1);
    $r = assertTrue(hasNurbsCurveAttribute($t1)); if (`size $r`) warning $r;
    if (`objExists $t1`) delete $t1;
  }

  print("test0 end\n");
}

/*-
@returns <>
@remarks ノード。
*/
proc test1() {
  print("test1 start\n");
  string $r;

  // isValidCurveTransform / createCurveTransform
  {
    string $t1 = createCurveTransform("test");
    $r = assertFalse(isValidCurveTransform("")); if (`size $r`) warning $r;
    $r = assertTrue(isValidCurveTransform($t1)); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0}, `getAttr ($t1 + ".st")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0}, `getAttr ($t1 + ".sr")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({1.0, 1.0, 1.0}, `getAttr ($t1 + ".ss")`, 0.001); if (`size $r`) warning $r;
    if (`objExists $t1`) delete $t1;
  }

  // isValidNurbsCurve
  {
    string $t = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 1 0 0`;
    string $shapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $t`;
    string $nc = $shapeNodes[0];
    $r = assertFalse(isValidNurbsCurve("")); if (`size $r`) warning $r;
    $r = assertFalse(isValidNurbsCurve($nc)); if (`size $r`) warning $r;
    addNurbsCurveAttribute($nc);
    $r = assertTrue(isValidNurbsCurve($nc)); if (`size $r`) warning $r;
    if (`objExists $t`) delete $t;
  }

  // isEditMode
  {
    string $t = createCurveTransform("test");
    $r = assertFalse(isEditMode($t)); if (`size $r`) warning $r;

    string $m = `createNode "composeMatrix" -ss`;
    connectAttr -f ($t + ".st") ($m + ".it");
    connectAttr -f ($t + ".sr") ($m + ".ir");
    connectAttr -f ($t + ".ss") ($m + ".is");
    $r = assertTrue(isEditMode($t)); if (`size $r`) warning $r;

    if (`objExists $m`) delete $m;
    if (`objExists $t`) delete $t;
  }

  // collectShapeNodes
  {
    string $ncs[];
    string $tx = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 1 0 0`;
    string $ty = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 0 1 0`;
    string $tz = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 0 0 1`;
    string $txShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $tx`;
    string $tyShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $ty`;
    string $tzShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $tz`;
    string $ncx = $txShapeNodes[0];
    string $ncy = $tyShapeNodes[0];
    string $ncz = $tzShapeNodes[0];
    $ncs[`size $ncs`] = $ncx;
    $ncs[`size $ncs`] = $ncy;
    $ncs[`size $ncs`] = $ncz;
    string $t = `createNode -ss "transform"`;
    parent -r -s $ncs $t;
    string $tnc1 = `substitute $tx $ncx $t`;
    string $tnc2 = `substitute $ty $ncy $t`;
    string $tnc3 = `substitute $tz $ncz $t`;

    string $locators[] = `spaceLocator`;
    string $l = $locators[0];
    string $lShapeNodes[] = `listRelatives -f -s -typ "locator" $l`;
    string $ls = $lShapeNodes[0];

    $r = assertFalse(isValidNurbsCurve($tnc1)); if (`size $r`) warning $r;
    $r = assertFalse(isValidNurbsCurve($tnc2)); if (`size $r`) warning $r;
    $r = assertFalse(isValidNurbsCurve($tnc3)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({}, collectShapeNodes($t, "nurbsCurve", true)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({$tnc1, $tnc2, $tnc3}, collectShapeNodes($t, "nurbsCurve", false)); if (`size $r`) warning $r;

    $r = assertStringArrayEqual({}, collectShapeNodes($l, "", true)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({$ls}, collectShapeNodes($l, "", false)); if (`size $r`) warning $r;

    addNurbsCurveAttribute($tnc1);
    addNurbsCurveAttribute($tnc2);
    addNurbsCurveAttribute($tnc3);
    $r = assertTrue(isValidNurbsCurve($tnc1)); if (`size $r`) warning $r;
    $r = assertTrue(isValidNurbsCurve($tnc2)); if (`size $r`) warning $r;
    $r = assertTrue(isValidNurbsCurve($tnc3)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({$tnc1, $tnc2, $tnc3}, collectShapeNodes($t, "nurbsCurve", true)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({$tnc1, $tnc2, $tnc3}, collectShapeNodes($t, "nurbsCurve", false)); if (`size $r`) warning $r;

    if (`objExists $tx`) delete $tx;
    if (`objExists $ty`) delete $ty;
    if (`objExists $tz`) delete $tz;
    if (`objExists $t`) delete $t;
    if (`objExists $l`) delete $l;
  }

  // renameCurveNodes
  {
    string $tx = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 1 0 0`;
    string $ty = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 0 1 0`;
    string $tz = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 0 0 1`;
    string $txShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $tx`;
    string $tyShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $ty`;
    string $tzShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $tz`;
    string $ncs[] = {$txShapeNodes[0], $tyShapeNodes[0], $tzShapeNodes[0]};
    string $p = longNameOf(`createNode -ss "transform"`);
    string $t = longNameOf(`createNode -p $p -ss "transform"`);
    string $newShapeNodes[] = {"Shape1", "Shape2", "Shape3"};
    stringArrayAddPrefix($newShapeNodes, shortNameOf($t));

    $r = assertTrue(`objExists $ncs[0]`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $ncs[1]`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $ncs[2]`); if (`size $r`) warning $r;

    parent -r -s $ncs $t;
    $r = assertFalse(`objExists $ncs[0]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $ncs[1]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $ncs[2]`); if (`size $r`) warning $r;

    $ncs = renameCurveNodes($t);
    $r = assertStringArrayEqual($newShapeNodes, $ncs); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $ncs[0]`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $ncs[1]`); if (`size $r`) warning $r;
    $r = assertTrue(`objExists $ncs[2]`); if (`size $r`) warning $r;

    if (`objExists $tx`) delete $tx;
    if (`objExists $ty`) delete $ty;
    if (`objExists $tz`) delete $tz;
    if (`objExists $t`) delete $t;
    if (`objExists $p`) delete $p;
  }

  // deleteNodes
  {
    string $t1 = `createNode -ss "transform"`;
    string $t2 = `createNode -ss "transform"`;
    string $t3 = `createNode -ss "transform"`;
    deleteNodes({$t1, $t2, $t3});
    $r = assertFalse(`objExists $t1`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $t2`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $t3`); if (`size $r`) warning $r;
  }

  print("test1 end\n");
}

/*-
@returns <>
@remarks カーブ定義。
*/
proc test2() {
  print("test2 start\n");
  string $r;

  // serializeCurve
  {
    string $t1 = `curve -d 1 -os -per 0 -k 0 -k 1 -p 0 0 0 -p 1 0 0`;
    string $shapeNodes1[] = `listRelatives -f -s -typ "nurbsCurve" $t1`;
    string $nc1 = $shapeNodes1[0];
    $r = assertStringEqual("", serializeCurve($t1)); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;1,0,0", serializeCurve($nc1)); if (`size $r`) warning $r;

    string $t2 = `curve -d 1 -os -per 1 -k 0 -k 1 -k 2 -k 3 -p 0 0 0 -p 1 0 0 -p 1 0 1 -p 0 0 0`;
    string $shapeNodes2[] = `listRelatives -f -s -typ "nurbsCurve" $t2`;
    string $nc2 = $shapeNodes2[0];
    $r = assertStringEqual("", serializeCurve($t2)); if (`size $r`) warning $r;
    $r = assertStringEqual("1,3,2,0,3/0,1,2,3/0,0,0;1,0,0;1,0,1;0,0,0", serializeCurve($nc2)); if (`size $r`) warning $r;

    if (`objExists $t1`) delete $t1;
    if (`objExists $t2`) delete $t2;
  }

  // bundleCurves
  {
    string $tx = `curve -d 1 -os -per 0 -k 0 -k 1 -p 0 0 0 -p 1 0 0`;
    string $ty = `curve -d 1 -os -per 0 -k 0 -k 1 -p 0 0 0 -p 0 1 0`;
    string $tz = `curve -d 1 -os -per 0 -k 0 -k 1 -p 0 0 0 -p 0 0 1`;
    string $txShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $tx`;
    string $tyShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $ty`;
    string $tzShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $tz`;
    string $ncx = $txShapeNodes[0];
    string $ncy = $tyShapeNodes[0];
    string $ncz = $tzShapeNodes[0];

    $r = assertStringEqual("", bundleCurves({})); if (`size $r`) warning $r;
    $r = assertStringEqual("", bundleCurves({$ncx})); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;1,0,0\n", bundleCurves({$tx})); if (`size $r`) warning $r;
    $r = assertStringEqual("", bundleCurves({$ncy})); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;0,1,0\n", bundleCurves({$ty})); if (`size $r`) warning $r;
    $r = assertStringEqual("", bundleCurves({$ncz})); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;0,0,1\n", bundleCurves({$tz})); if (`size $r`) warning $r;
    $r = assertStringEqual("", bundleCurves({$ncx, $ncy, $ncz})); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;1,0,0\n1,1,0,0,3/0,1/0,0,0;0,1,0\n1,1,0,0,3/0,1/0,0,0;0,0,1\n", bundleCurves({$tx, $ty, $tz})); if (`size $r`) warning $r;

    if (`objExists $tx`) delete $tx;
    if (`objExists $ty`) delete $ty;
    if (`objExists $tz`) delete $tz;
  }

  // deserializeCurve
  {
    string $curveText1 = "1,1,0,0,3/0,1/0,0,0;1,0,0";

    $r = assertStringEqual("", deserializeCurve("")); if (`size $r`) warning $r;
    $r = assertStringEqual("", deserializeCurve("1")); if (`size $r`) warning $r;
    $r = assertStringEqual("", deserializeCurve("1/2")); if (`size $r`) warning $r;
    $r = assertStringEqual("", deserializeCurve("1/2/3")); if (`size $r`) warning $r;
    $r = assertStringEqual("", deserializeCurve("1,1/2/3")); if (`size $r`) warning $r;
    $r = assertStringEqual("", deserializeCurve("1,1,0/2/3")); if (`size $r`) warning $r;
    $r = assertStringEqual("", deserializeCurve("1,1,1,1/2/3")); if (`size $r`) warning $r;
    $r = assertStringEqual("", deserializeCurve("1,1,1,1,1/2/3")); if (`size $r`) warning $r;
    $r = assertStringEqual("", deserializeCurve("1,1,1,1,1/2/3,3;3,3")); if (`size $r`) warning $r;

    string $t1 = deserializeCurve($curveText1);
    $r = assertTrue(`objExists $t1`); if (`size $r`) warning $r;
    $r = assertStringEqual("transform", `nodeType $t1`); if (`size $r`) warning $r;
    string $shapeNodes1[] = `listRelatives -f -s -typ "nurbsCurve" $t1`;
    $r = assertIntEqual(1, `size $shapeNodes1`); if (`size $r`) warning $r;
    string $nc1 = $shapeNodes1[0];
    $r = assertTrue(`objExists $nc1`); if (`size $r`) warning $r;
    $r = assertStringEqual("nurbsCurve", `nodeType $nc1`); if (`size $r`) warning $r;
    $r = assertTrue(`attributeQuery -n $nc1 -ex "sourceCurve"`); if (`size $r`) warning $r;
    $r = assertStringEqual("nurbsCurve", `getAttr -typ ($nc1 + ".sourceCurve")`); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($nc1 + ".d")`); if (`size $r`) warning $r;
    $r = assertIntEqual(1, `getAttr ($nc1 + ".s")`); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($nc1 + ".f")`); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0, 1.0, 0.0, 0.0}, `getAttr ($nc1 + ".cp[*]")`, 0.001); if (`size $r`) warning $r;

    // 次数の異なるカーブをアタッチした時にできるClosedなカーブ
    string $curveText2 = "2,3,1,0,3/0,0,1,1,2,2/0,0,-1;-1,0,0;0,0,1;0,0,0;0,0,-1";

    string $t2 = deserializeCurve($curveText2);
    $r = assertTrue(`objExists $t2`); if (`size $r`) warning $r;
    $r = assertStringEqual("transform", `nodeType $t2`); if (`size $r`) warning $r;
    string $shapeNodes2[] = `listRelatives -f -s -typ "nurbsCurve" $t2`;
    $r = assertIntEqual(1, `size $shapeNodes2`); if (`size $r`) warning $r;
    string $nc2 = $shapeNodes2[0];
    $r = assertTrue(`objExists $nc2`); if (`size $r`) warning $r;
    $r = assertStringEqual("nurbsCurve", `nodeType $nc2`); if (`size $r`) warning $r;
    $r = assertTrue(`attributeQuery -n $nc2 -ex "sourceCurve"`); if (`size $r`) warning $r;
    $r = assertStringEqual("nurbsCurve", `getAttr -typ ($nc2 + ".sourceCurve")`); if (`size $r`) warning $r;
    $r = assertIntEqual(2, `getAttr ($nc2 + ".d")`); if (`size $r`) warning $r;
    $r = assertIntEqual(3, `getAttr ($nc2 + ".s")`); if (`size $r`) warning $r;
    $r = assertIntEqual(0, `getAttr ($nc2 + ".f")`); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, -1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0}, `getAttr ($nc2 + ".cp[*]")`, 0.001); if (`size $r`) warning $r;

    if (`objExists $t1`) delete $t1;
    if (`objExists $t2`) delete $t2;
  }

  print("test2 end\n");
}

/*-
@returns <>
@remarks カーブリスト。
*/
proc test3() {
  string $curveDirname = `getenv "MAYA_APP_DIR"` + "/dev/nkCurveDepot/nkCurveDepotCurves";
  string $trashDirname = $curveDirname + "/trash";
  string $curveOrderFilename = $curveDirname + "/order.txt";

  int $existsOrderFile = existsFilename($curveOrderFilename);
  string $lastOrderContent;
  if ($existsOrderFile) {
    $lastOrderContent = readAllText($curveOrderFilename, "");
    deleteFile($curveOrderFilename);
  }

  print("test3 start\n");
  string $r;

  // getCurveDirname
  $r = assertStringEqual($curveDirname, getCurveDirname()); if (`size $r`) warning $r;

  // getCurveDirname
  $r = assertStringEqual($trashDirname, getTrashDirname()); if (`size $r`) warning $r;

  // getCurveOrderFilename
  $r = assertStringEqual($curveOrderFilename, getCurveOrderFilename()); if (`size $r`) warning $r;

  // readCurveOrder
  {
    $r = assertStringArrayEqual({}, readCurveOrder()); if (`size $r`) warning $r;
    writeAllText($curveOrderFilename, "", "");
    $r = assertStringArrayEqual({}, readCurveOrder()); if (`size $r`) warning $r;
    writeAllText($curveOrderFilename, "", "a\nb\n");
    $r = assertStringArrayEqual({"a", "b"}, readCurveOrder()); if (`size $r`) warning $r;
    if (existsFilename($curveOrderFilename)) deleteFile($curveOrderFilename);
  }

  // writeCurveOrder
  {
    $r = assertTrue(writeCurveOrder({})); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($curveOrderFilename)); if (`size $r`) warning $r;
    $r = assertTrue(writeCurveOrder({"a", "b"})); if (`size $r`) warning $r;
    $r = assertStringEqual("a\nb\n", readAllText($curveOrderFilename, "")); if (`size $r`) warning $r;
    if (existsFilename($curveOrderFilename)) deleteFile($curveOrderFilename);
  }

  // sortCurveOrder
  {
    $r = assertFalse(existsFilename($curveOrderFilename)); if (`size $r`) warning $r;
    $r = assertFalse(sortCurveOrder()); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($curveOrderFilename)); if (`size $r`) warning $r;
    $r = assertTrue(writeAllText($curveOrderFilename, "", "c\na\nd\nb\n")); if (`size $r`) warning $r;
    $r = assertTrue(sortCurveOrder()); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"a", "b", "c", "d"}, readCurveOrder()); if (`size $r`) warning $r;
    if (existsFilename($curveOrderFilename)) deleteFile($curveOrderFilename);
  }

  // getCurveNameByIndex
  {
    $r = assertTrue(writeAllText($curveOrderFilename, "", "a\nb\nc\n")); if (`size $r`) warning $r;
    $r = assertStringEqual("", getCurveNameByIndex(-1)); if (`size $r`) warning $r;
    $r = assertStringEqual("", getCurveNameByIndex(3)); if (`size $r`) warning $r;
    $r = assertStringEqual("a", getCurveNameByIndex(0)); if (`size $r`) warning $r;
    $r = assertStringEqual("b", getCurveNameByIndex(1)); if (`size $r`) warning $r;
    $r = assertStringEqual("c", getCurveNameByIndex(2)); if (`size $r`) warning $r;
    if (existsFilename($curveOrderFilename)) deleteFile($curveOrderFilename);
  }

  // escapeCurveName
  $r = assertStringEqual("", escapeCurveName("")); if (`size $r`) warning $r;
  $r = assertStringEqual(" ", escapeCurveName(" ")); if (`size $r`) warning $r;
  $r = assertStringEqual("abcdefghijklmnopqrstuvwxyz", escapeCurveName("abcdefghijklmnopqrstuvwxyz")); if (`size $r`) warning $r;
  $r = assertStringEqual("ABCDEFGHIJKLMNOPQRSTUVWXYZ", escapeCurveName("ABCDEFGHIJKLMNOPQRSTUVWXYZ")); if (`size $r`) warning $r;
  $r = assertStringEqual("0123456789", escapeCurveName("0123456789")); if (`size $r`) warning $r;
  $r = assertStringEqual("_-,;!.'()[]{}@&#%`^+=~$", escapeCurveName("_-,;!.'()[]{}@&#%`^+=~$")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a:b")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a?b")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a\"b")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a*b")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a/b")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a\\b")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a<b")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a>b")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a|b")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a\nb")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a\rb")); if (`size $r`) warning $r;
  $r = assertStringEqual("a b", escapeCurveName("a\tb")); if (`size $r`) warning $r;

  // makeCurveFilename
  $r = assertStringEqual($curveDirname + "/a.curvedepot", makeCurveFilename("a")); if (`size $r`) warning $r;

  // makeTrashFilename
  $r = assertStringEqual($trashDirname + "/a.curvedepot", makeTrashFilename("a")); if (`size $r`) warning $r;

  // addCurve
  {
    string $t = `createNode -ss "transform"`;
    string $tx = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 1 0 0`;
    string $ty = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 0 1 0`;
    string $tz = `curve -d 1 -k 0 -k 1 -p 0 0 0 -p 0 0 1`;
    string $txShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $tx`;
    string $tyShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $ty`;
    string $tzShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $tz`;
    string $ncx = $txShapeNodes[0];
    string $ncy = $tyShapeNodes[0];
    string $ncz = $tzShapeNodes[0];

    string $xCurveFilename = $curveDirname + "/x.curvedepot";
    string $yCurveFilename = $curveDirname + "/y.curvedepot";
    string $zCurveFilename = $curveDirname + "/z.curvedepot";
    string $xyzCurveFilename = $curveDirname + "/x y z.curvedepot";

    $r = assertFalse(existsFilename($curveOrderFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($xCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($yCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($zCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($xyzCurveFilename)); if (`size $r`) warning $r;

    $r = assertFalse(addCurve("", {$tx})); if (`size $r`) warning $r;
    $r = assertFalse(addCurve("x", {})); if (`size $r`) warning $r;
    $r = assertFalse(addCurve("x", {$ncx})); if (`size $r`) warning $r;

    $r = assertTrue(addCurve("x", {$tx})); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xCurveFilename)); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;1,0,0\n", readAllText($xCurveFilename, "")); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertFalse(addCurve("x", {$tx})); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertTrue(addCurve("y", {$ty})); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($yCurveFilename)); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;0,1,0\n", readAllText($yCurveFilename, "")); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x", "y"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertTrue(addCurve("z", {$tz})); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($zCurveFilename)); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;0,0,1\n", readAllText($zCurveFilename, "")); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x", "y", "z"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertTrue(addCurve("x<y>z", {$tx, $ty, $tz})); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xyzCurveFilename)); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;1,0,0\n1,1,0,0,3/0,1/0,0,0;0,1,0\n1,1,0,0,3/0,1/0,0,0;0,0,1\n", readAllText($xyzCurveFilename, "")); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x", "y", "z", "x y z"}, readCurveOrder()); if (`size $r`) warning $r;

    if (existsFilename($curveOrderFilename)) deleteFile($curveOrderFilename);
    if (existsFilename($xCurveFilename)) deleteFile($xCurveFilename);
    if (existsFilename($yCurveFilename)) deleteFile($yCurveFilename);
    if (existsFilename($zCurveFilename)) deleteFile($zCurveFilename);
    if (existsFilename($xyzCurveFilename)) deleteFile($xyzCurveFilename);
    if (`objExists $t`) delete $t;
    if (`objExists $tx`) delete $tx;
    if (`objExists $ty`) delete $ty;
    if (`objExists $tz`) delete $tz;
  }

  // deleteCurve
  {
    string $xCurveFilename = $curveDirname + "/x.curvedepot";
    string $yCurveFilename = $curveDirname + "/y.curvedepot";
    string $zCurveFilename = $curveDirname + "/z.curvedepot";
    string $xTrashFilename = $trashDirname + "/x.curvedepot";
    string $yTrashFilename = $trashDirname + "/y.curvedepot";
    string $zTrashFilename = $trashDirname + "/z.curvedepot";

    $r = assertTrue(writeAllText($curveOrderFilename, "", "x\ny\nz\n")); if (`size $r`) warning $r;
    $r = assertTrue(writeAllText($xCurveFilename, "", "")); if (`size $r`) warning $r;
    $r = assertTrue(writeAllText($yCurveFilename, "", "")); if (`size $r`) warning $r;
    $r = assertTrue(writeAllText($zCurveFilename, "", "")); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($curveOrderFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($yCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($zCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($xTrashFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($yTrashFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($zTrashFilename)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x", "y", "z"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertFalse(deleteCurve(-1)); if (`size $r`) warning $r;
    $r = assertFalse(deleteCurve(3)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($yCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($zCurveFilename)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x", "y", "z"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertTrue(deleteCurve(1)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($yCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($zCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($xTrashFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($yTrashFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($zTrashFilename)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x", "z"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertTrue(deleteCurve(0)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($xCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($yCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($zCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xTrashFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($yTrashFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($zTrashFilename)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"z"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertTrue(deleteCurve(0)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($xCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($yCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($zCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xTrashFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($yTrashFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($zTrashFilename)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({}, readCurveOrder()); if (`size $r`) warning $r;
    $r = assertStringEqual("", readAllText($curveOrderFilename, "")); if (`size $r`) warning $r;

    if (existsFilename($xTrashFilename)) deleteFile($xTrashFilename);
    if (existsFilename($yTrashFilename)) deleteFile($yTrashFilename);
    if (existsFilename($zTrashFilename)) deleteFile($zTrashFilename);
    if (existsFilename($curveOrderFilename)) deleteFile($curveOrderFilename);
  }

  // renameCurve
  {
    string $xCurveFilename = $curveDirname + "/x.curvedepot";
    string $yCurveFilename = $curveDirname + "/y.curvedepot";
    string $zCurveFilename = $curveDirname + "/z.curvedepot";
    string $xyzCurveFilename = $curveDirname + "/x y z.curvedepot";

    $r = assertTrue(writeAllText($curveOrderFilename, "", "x\ny\nz\n")); if (`size $r`) warning $r;
    $r = assertTrue(writeAllText($xCurveFilename, "", "")); if (`size $r`) warning $r;
    $r = assertTrue(writeAllText($yCurveFilename, "", "")); if (`size $r`) warning $r;
    $r = assertTrue(writeAllText($zCurveFilename, "", "")); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($curveOrderFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($yCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($zCurveFilename)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x", "y", "z"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertFalse(renameCurve(1, "")); if (`size $r`) warning $r;
    $r = assertFalse(renameCurve(-1, "x<y>z")); if (`size $r`) warning $r;
    $r = assertFalse(renameCurve(3, "x<y>z")); if (`size $r`) warning $r;
    $r = assertTrue(renameCurve(1, "x<y>z")); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xCurveFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($yCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($zCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xyzCurveFilename)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x", "x y z", "z"}, readCurveOrder()); if (`size $r`) warning $r;

    if (existsFilename($xCurveFilename)) deleteFile($xCurveFilename);
    if (existsFilename($yCurveFilename)) deleteFile($yCurveFilename);
    if (existsFilename($zCurveFilename)) deleteFile($zCurveFilename);
    if (existsFilename($xyzCurveFilename)) deleteFile($xyzCurveFilename);
    if (existsFilename($curveOrderFilename)) deleteFile($curveOrderFilename);
  }

  // movePrevCurve / moveNextCurve
  {
    $r = assertTrue(writeAllText($curveOrderFilename, "", "x\ny\nz\n")); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($curveOrderFilename)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"x", "y", "z"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertFalse(movePrevCurve(-1)); if (`size $r`) warning $r;
    $r = assertFalse(movePrevCurve(3)); if (`size $r`) warning $r;
    $r = assertFalse(movePrevCurve(0)); if (`size $r`) warning $r;
    $r = assertTrue(movePrevCurve(1)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"y", "x", "z"}, readCurveOrder()); if (`size $r`) warning $r;

    $r = assertFalse(moveNextCurve(-1)); if (`size $r`) warning $r;
    $r = assertFalse(moveNextCurve(3)); if (`size $r`) warning $r;
    $r = assertFalse(moveNextCurve(2)); if (`size $r`) warning $r;
    $r = assertTrue(moveNextCurve(1)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"y", "z", "x"}, readCurveOrder()); if (`size $r`) warning $r;

    if (existsFilename($curveOrderFilename)) deleteFile($curveOrderFilename);
  }

  print("test3 end\n");

  if ($existsOrderFile) {
    writeAllText($curveOrderFilename, "", $lastOrderContent);
  }
}

/*-
@returns <>
@remarks カーブ操作。
*/
proc test4() {
  string $curveDirname = `getenv "MAYA_APP_DIR"` + "/dev/nkCurveDepot/nkCurveDepotCurves";
  string $curveOrderFilename = $curveDirname + "/order.txt";

  int $existsOrderFile = existsFilename($curveOrderFilename);
  string $lastOrderContent;
  if ($existsOrderFile) {
    $lastOrderContent = readAllText($curveOrderFilename, "");
    deleteFile($curveOrderFilename);
  }

  print("test4 start\n");
  string $r;

  // createCurve
  {
    string $xyzCurveFilename = $curveDirname + "/xyz.curvedepot";

    $r = assertFalse(existsFilename($curveOrderFilename)); if (`size $r`) warning $r;
    $r = assertFalse(existsFilename($xyzCurveFilename)); if (`size $r`) warning $r;
    $r = assertTrue(writeAllText($curveOrderFilename, "", "xyz\n")); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($curveOrderFilename)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({"xyz"}, readCurveOrder()); if (`size $r`) warning $r;
    $r = assertTrue(writeAllText($xyzCurveFilename, "", "1,1,0,0,3/0,1/0,0,0;1,0,0\n1,1,0,0,3/0,1/0,0,0;0,1,0\n1,1,0,0,3/0,1/0,0,0;0,0,1\n")); if (`size $r`) warning $r;
    $r = assertTrue(existsFilename($xyzCurveFilename)); if (`size $r`) warning $r;
    $r = assertStringEqual("1,1,0,0,3/0,1/0,0,0;1,0,0\n1,1,0,0,3/0,1/0,0,0;0,1,0\n1,1,0,0,3/0,1/0,0,0;0,0,1\n", readAllText($xyzCurveFilename, "")); if (`size $r`) warning $r;

    string $t = createCurve("xyz");
    $r = assertTrue(isValidCurveTransform($t)); if (`size $r`) warning $r;
    string $shapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $t`;
    $r = assertIntEqual(3, `size $shapeNodes`); if (`size $r`) warning $r;
    string $ncx = $shapeNodes[0];
    $r = assertTrue(isValidNurbsCurve($ncx)); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0, 1.0, 0.0, 0.0}, `getAttr ($ncx + ".cp[*]")`, 0.001); if (`size $r`) warning $r;
    string $ncy = $shapeNodes[1];
    $r = assertTrue(isValidNurbsCurve($ncy)); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0, 0.0, 1.0, 0.0}, `getAttr ($ncy + ".cp[*]")`, 0.001); if (`size $r`) warning $r;
    string $ncz = $shapeNodes[2];
    $r = assertTrue(isValidNurbsCurve($ncz)); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0, 0.0, 0.0, 1.0}, `getAttr ($ncz + ".cp[*]")`, 0.001); if (`size $r`) warning $r;

    string $stx = $t + ".stx";
    string $sty = $t + ".sty";
    string $stz = $t + ".stz";
    string $srx = $t + ".srx";
    string $sry = $t + ".sry";
    string $srz = $t + ".srz";
    string $ssx = $t + ".ssx";
    string $ssy = $t + ".ssy";
    string $ssz = $t + ".ssz";
    string $cn = $t + ".cn";

    $r = assertTrue(`getAttr -l $stx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $sty`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $stz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $srx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $sry`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $srz`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $ssx`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $ssy`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $ssz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $stx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $sty`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $stz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $srx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $sry`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $srz`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssx`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssy`); if (`size $r`) warning $r;
    $r = assertFalse(`getAttr -cb $ssz`); if (`size $r`) warning $r;

    $r = assertStringEqual("xyz", `getAttr $cn`); if (`size $r`) warning $r;
    $r = assertTrue(`getAttr -l $cn`); if (`size $r`) warning $r;

    if (existsFilename($curveOrderFilename)) deleteFile($curveOrderFilename);
    if (existsFilename($xyzCurveFilename)) deleteFile($xyzCurveFilename);
    if (`objExists $t`) delete $t;
  }

  // buildEditableGraph / removeEditableGraph / lockCurve
  {
    string $t = `curve -d 1 -os -per 0 -k 0 -k 1 -p 0 0 0 -p 1 0 0`;
    addCurveTransformAttribute($t);
    string $shapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $t`;
    string $nc = $shapeNodes[0];
    addNurbsCurveAttribute($nc);
    setAttr ($nc + ".sc") -typ "nurbsCurve" 1 1 0 0 3 2 0 1 2 0 0 0 1 0 0;
    $r = assertTrue(isValidCurveTransform($t)); if (`size $r`) warning $r;
    $r = assertTrue(isValidNurbsCurve($nc)); if (`size $r`) warning $r;

    string $nodes[] = buildEditableGraph({$t});
    $r = assertIntEqual(7, `size $nodes`); if (`size $r`) warning $r;
    $r = assertStringEqual("composeMatrix", `nodeType $nodes[0]`); if (`size $r`) warning $r;
    $r = assertStringEqual("colorMath",     `nodeType $nodes[1]`); if (`size $r`) warning $r;
    $r = assertStringEqual("curveInfo",     `nodeType $nodes[2]`); if (`size $r`) warning $r;
    $r = assertStringEqual("vectorProduct", `nodeType $nodes[3]`); if (`size $r`) warning $r;
    $r = assertStringEqual("colorMath",     `nodeType $nodes[4]`); if (`size $r`) warning $r;
    $r = assertStringEqual("vectorProduct", `nodeType $nodes[5]`); if (`size $r`) warning $r;
    $r = assertStringEqual("colorMath",     `nodeType $nodes[6]`); if (`size $r`) warning $r;

    removeEditableGraph({$t});
    $r = assertFalse(`objExists $nodes[0]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $nodes[1]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $nodes[2]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $nodes[3]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $nodes[4]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $nodes[5]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $nodes[6]`); if (`size $r`) warning $r;

    if (`objExists $t`) delete $t;
  }

  // replaceCurves
  {
    string $t1 = `curve -d 1 -os -per 0 -k 0 -k 1 -p 0 0 0 -p 1 0 0`;
    string $t2 = `curve -d 1 -os -per 0 -k 0 -k 1 -p 0 0 0 -p 0 1 0`;
    string $t3 = `curve -d 1 -os -per 0 -k 0 -k 1 -p 0 0 0 -p 0 0 1`;
    string $t1ShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $t1`;
    string $t2ShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $t2`;
    string $t3ShapeNodes[] = `listRelatives -f -s -typ "nurbsCurve" $t3`;
    string $nc1 = $t1ShapeNodes[0];
    string $nc2 = $t2ShapeNodes[0];
    string $nc3 = $t3ShapeNodes[0];
    string $ncs[];

    $r = assertStringArrayEqual({}, replaceCurves({})); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({}, replaceCurves({$t1})); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({}, replaceCurves({$t1, $t2, $t3})); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({}, replaceCurves({$t1, $t2})); if (`size $r`) warning $r;

    addCurveTransformAttribute($t1);
    $r = assertStringArrayEqual({}, replaceCurves({$t1, $nc2})); if (`size $r`) warning $r;
    addNurbsCurveAttribute($nc1);
    setAttr ($t1 + ".sr") -typ "double3" 0.0 0.0 90.0;
    setAttr ($t1 + ".ss") -typ "double3" 2.0 1.0 1.0;
    setAttr ($t1 + ".cn") -typ "string" "curve1";
    setAttr ($nc1 + ".sc") -typ "nurbsCurve" 1 1 0 0 3 2 0 1 2 0 0 0 1 0 0;
    $r = assertTrue(isValidCurveTransform($t1)); if (`size $r`) warning $r;
    $r = assertTrue(isValidNurbsCurve($nc1)); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0}, `getAttr ($t1 + ".st")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 90.0}, `getAttr ($t1 + ".sr")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({2.0, 1.0, 1.0}, `getAttr ($t1 + ".ss")`, 0.001); if (`size $r`) warning $r;
    $r = assertStringEqual("curve1", `getAttr ($t1 + ".cn")`); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0, 1.0, 0.0, 0.0}, `getAttr ($nc1 + ".cp[*]")`, 0.001); if (`size $r`) warning $r;

    $r = assertFalse(isValidCurveTransform($t2)); if (`size $r`) warning $r;
    $r = assertFalse(isValidNurbsCurve($nc2)); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0, 0.0, 1.0, 0.0}, `getAttr ($nc2 + ".cp[*]")`, 0.001); if (`size $r`) warning $r;

    addCurveTransformAttribute($t3);
    addNurbsCurveAttribute($nc3);
    setAttr ($t3 + ".sr") -typ "double3" 0.0 90.0 0.0;
    setAttr ($t3 + ".ss") -typ "double3" 3.0 0.0 0.0;
    setAttr ($t3 + ".cn") -typ "string" "curve3";
    setAttr ($nc3 + ".sc") -typ "nurbsCurve" 1 1 0 0 3 2 0 1 2 0 0 0 0 0 1;
    $r = assertTrue(isValidCurveTransform($t3)); if (`size $r`) warning $r;
    $r = assertTrue(isValidNurbsCurve($nc3)); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0}, `getAttr ($t3 + ".st")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 90.0, 0.0}, `getAttr ($t3 + ".sr")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({3.0, 0.0, 0.0}, `getAttr ($t3 + ".ss")`, 0.001); if (`size $r`) warning $r;
    $r = assertStringEqual("curve3", `getAttr ($t3 + ".cn")`); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0, 0.0, 0.0, 1.0}, `getAttr ($nc3 + ".cp[*]")`, 0.001); if (`size $r`) warning $r;

    $t2ShapeNodes = replaceCurves({$t1, $t2});
    $r = assertTrue(isValidCurveTransform($t2)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({$t2 + "Shape1"}, $t2ShapeNodes); if (`size $r`) warning $r;
    $r = assertTrue(isValidNurbsCurve($t2ShapeNodes[0])); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0}, `getAttr ($t2 + ".st")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0}, `getAttr ($t2 + ".sr")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({1.0, 1.0, 1.0}, `getAttr ($t2 + ".ss")`, 0.001); if (`size $r`) warning $r;
    $r = assertStringEqual("curve1", `getAttr ($t2 + ".cn")`); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0, 1.0, 0.0, 0.0}, `getAttr ($t2ShapeNodes[0] + ".cp[*]")`, 0.001); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $t1`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $t1ShapeNodes[0]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $nc2`); if (`size $r`) warning $r;

    $t3ShapeNodes = replaceCurves({$t2, $t3});
    $r = assertTrue(isValidCurveTransform($t3)); if (`size $r`) warning $r;
    $r = assertStringArrayEqual({$t3 + "Shape1"}, $t3ShapeNodes); if (`size $r`) warning $r;
    $r = assertTrue(isValidNurbsCurve($t3ShapeNodes[0])); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0}, `getAttr ($t3 + ".st")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 90.0, 0.0}, `getAttr ($t3 + ".sr")`, 0.001); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({3.0, 0.0, 0.0}, `getAttr ($t3 + ".ss")`, 0.001); if (`size $r`) warning $r;
    $r = assertStringEqual("curve1", `getAttr ($t3 + ".cn")`); if (`size $r`) warning $r;
    $r = assertFloatArrayEqual({0.0, 0.0, 0.0, 0.0, 0.0, -3.0}, `getAttr ($t3ShapeNodes[0] + ".cp[*]")`, 0.001); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $t2`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $t2ShapeNodes[0]`); if (`size $r`) warning $r;
    $r = assertFalse(`objExists $nc3`); if (`size $r`) warning $r;

    if (`objExists $t1`) delete $t1;
    if (`objExists $t2`) delete $t2;
    if (`objExists $t3`) delete $t3;
  }

  print("test4 end\n");

  if ($existsOrderFile) {
    writeAllText($curveOrderFilename, "", $lastOrderContent);
  }
}

/*-
@param $flags <boolean[]>
@returns <>
*/
global proc nkCurveDepotTest(int $flags[]) {
  if ($flags[0]) test0();
  if ($flags[1]) test1();
  if ($flags[2]) test2();
  if ($flags[3]) test3();
  if ($flags[4]) test4();
}

/*
eval ("source \"" + `getenv "MAYA_APP_DIR"` + "/dev/nkCurveDepot/nkCurveDepot.mel\"");
nkCurveDepotTest({1, 1, 1, 1, 1});
*/
